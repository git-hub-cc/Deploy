[
  {
    "name": "什么是设计模式",
    "summary": "在特定情境下对软件设计中常见问题的优雅、可复用的解决方案，是前人经验的总结。",
    "notes": "# 什么是设计模式\n\n## 定义 (Definition)\n\n设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在特定场景下，如何解决一类重复出现的设计问题。设计模式不是具体的代码或算法，而是一种解决问题的思想和蓝图。它不是强制性的，而是一系列建议，旨在帮助开发者构建更健壮、更灵活、更易于维护的软件系统。\n\n## 目的与价值 (Purpose & Value)\n\n- **提高代码复用性**：模式提供了一种标准化的方式来解决问题，使得解决方案可以被复用。\n- **增强可读性和可维护性**：使用公认的设计模式可以让其他开发者更快地理解代码的意图和结构，降低维护成本。\n- **提供通用词汇**：为开发者提供了一套通用的设计词汇，使得沟通更加高效和精确（例如，当你说“这里用一个单例”时，团队成员都能明白其含义）。\n- **提升系统健壮性**：遵循设计模式通常会使系统设计更加符合面向对象的设计原则，从而获得更好的扩展性和灵活性。\n\n## 设计模式的分类 (Classification)\n\n根据模式的目的，通常将其分为三类：\n\n### 1. 创建型模式 (Creational Patterns)\n\n这类模式关注对象的创建过程，旨在将对象的创建与使用解耦，使得系统在创建对象时更具灵活性。\n\n- **核心思想**：封装创建逻辑，隐藏对象的具体创建细节。\n- **包含模式**：\n  - 单例模式 (Singleton)\n  - 工厂方法模式 (Factory Method)\n  - 抽象工厂模式 (Abstract Factory)\n  - 建造者模式 (Builder)\n  - 原型模式 (Prototype)\n\n### 2. 结构型模式 (Structural Patterns)\n\n这类模式关注如何将类和对象组合成更大的结构，同时保持结构的灵活性和效率。\n\n- **核心思想**：通过组合和继承来形成更复杂、功能更强大的结构。\n- **包含模式**：\n  - 适配器模式 (Adapter)\n  - 装饰器模式 (Decorator)\n  - 代理模式 (Proxy)\n  - 外观模式 (Facade)\n  - 桥接模式 (Bridge)\n  - 组合模式 (Composite)\n  - 享元模式 (Flyweight)\n\n### 3. 行为型模式 (Behavioral Patterns)\n\n这类模式关注对象之间的职责分配和通信，旨在有效地组织对象间的协作关系。\n\n- **核心思想**：管理对象间的算法、职责和协作方式。\n- **包含模式**：\n  - 策略模式 (Strategy)\n  - 模板方法模式 (Template Method)\n  - 观察者模式 (Observer)\n  - 责任链模式 (Chain of Responsibility)\n  - 命令模式 (Command)\n  - 迭代器模式 (Iterator)\n  - 状态模式 (State)\n  - 访问者模式 (Visitor)\n  - 备忘录模式 (Memento)\n  - 中介者模式 (Mediator)\n  - 解释器模式 (Interpreter)"
  },
  {
    "name": "设计模式六大原则",
    "summary": "指导我们进行高质量软件设计的六个核心原则，是理解和运用设计模式的基础，通常以 SOLID 原则著称。",
    "notes": "# 设计模式六大原则\n\n这六大原则是面向对象设计的基石，遵循它们可以帮助我们编写出高内聚、低耦合、易于维护和扩展的代码。它们是理解和掌握设计模式的前提。\n\n## 1. 单一职责原则 (Single Responsibility Principle, SRP)\n\n- **定义**：一个类或模块应该只负责一项职责（或功能）。就一个类而言，应该仅有一个引起它变化的原因。\n- **目的**：降低类的复杂度和耦合度。当一个类负责的职责过多时，任何一个职责的变化都可能影响到其他职责，导致代码脆弱且难以维护。\n- **示例**：一个 `User` 类应该只负责用户的属性和基本行为，而不应该包含连接数据库、发送邮件等与用户核心业务无关的职责。\n\n## 2. 开闭原则 (Open/Closed Principle, OCP)\n\n- **定义**：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。\n- **目的**：在不修改现有代码的基础上，通过增加新代码来扩展系统功能。这是实现系统可维护性和可扩展性的核心原则。\n- **示例**：一个支付系统，当需要增加一种新的支付方式（如微信支付）时，不应该去修改原有的支付处理类，而是应该通过添加一个新的支付策略类来扩展功能。\n\n## 3. 里氏替换原则 (Liskov Substitution Principle, LSP)\n\n- **定义**：所有引用基类的地方必须能透明地使用其子类的对象。简单来说，子类对象能够替换父类对象，而程序的逻辑行为不发生改变。\n- **目的**：保证继承的正确性，确保子类不会破坏父类的行为约定，是实现开闭原则的重要方式之一。\n- **示例**：如果一个方法接受一个 `Animal` 类型的参数并调用其 `move()` 方法。那么传入它的任何子类（如 `Dog`, `Cat`）时，程序都不应该出错或产生意外行为。子类可以有自己的实现，但不能违背父类的契约。\n\n## 4. 接口隔离原则 (Interface Segregation Principle, ISP)\n\n- **定义**：客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。\n- **目的**：避免接口过于臃肿。将庞大的接口拆分成更小、更具体的接口，使得客户端只需关心与自己相关的接口。\n- **示例**：一个 `SmartDevice` 接口不应该同时包含 `call()`、`playMusic()` 和 `cook()` 方法。应该将其拆分为 `PhoneInterface`, `MusicPlayerInterface`, `CookerInterface` 等更小的接口，让不同的设备类按需实现。\n\n## 5. 依赖倒置原则 (Dependence Inversion Principle, DIP)\n\n- **定义**：高层模块不应该依赖低层模块，两者都应该依赖于抽象。抽象不应该依赖细节，细节应该依赖于抽象。\n- **目的**：实现模块间的解耦。通过面向接口编程，而不是面向实现编程，使得系统更加灵活，易于替换和测试。\n- **示例**：一个 `BusinessService` (高层模块) 不应该直接依赖 `MySqlDatabase` (低层模块)，而应该依赖一个 `Database` 接口。`MySqlDatabase` 和 `OracleDatabase` 都去实现这个接口。这样，底层数据库的更换不会影响到高层业务逻辑。\n\n## 6. 迪米特法则 (Law of Demeter, LoD) / 最少知识原则\n\n- **定义**：一个对象应该对其他对象保持最少的了解。即一个对象只与它直接的朋友（成员变量、方法参数、方法返回值等）通信。\n- **目的**：降低类与类之间的耦合度，限制信息传播的范围，从而提高系统的模块化。\n- **示例**：在一个 `Boss` 类中，要让 `TeamLeader` 指派任务给 `Developer`。`Boss` 应该只调用 `TeamLeader` 的 `assignTask` 方法，而不应该通过 `boss.getTeamLeader().getDeveloper().doWork()` 这种方式直接与 `Developer` 交互。`TeamLeader` 内部如何与 `Developer` 沟通，对 `Boss` 应该是透明的。"
  },
  {
    "name": "单例模式",
    "summary": "确保一个类只有一个实例，并提供一个全局访问点来获取这个唯一的实例。",
    "notes": "# 单例模式 (Singleton Pattern)\n\n## 解决的问题\n\n在某些场景下，一个类只需要一个实例就足够了，例如全局配置对象、数据库连接池、线程池等。单例模式解决了以下问题：\n\n- **资源节约**：避免重复创建重量级对象，节省系统内存和计算资源。\n- **数据一致性**：保证所有操作都针对同一个实例，防止因多个实例导致的状态不一致问题。\n- **全局访问**：提供一个统一的访问点，方便程序在任何地方获取该实例。\n\n## 核心思想与实现方式\n\n核心思想是：将类的构造函数私有化，防止外部直接创建实例，并通过一个静态方法返回内部维护的唯一实例。\n\n### 1. 饿汉式 (Eager Initialization)\n\n在类加载时就创建实例，线程安全，但可能造成资源浪费。\n\n```java\npublic class SingletonEager {\n    private static final SingletonEager INSTANCE = new SingletonEager();\n\n    private SingletonEager() {}\n\n    public static SingletonEager getInstance() {\n        return INSTANCE;\n    }\n}\n```\n\n### 2. 懒汉式 (Lazy Initialization) - 线程不安全\n\n在第一次调用 `getInstance()` 时才创建实例，但在多线程环境下可能创建多个实例。\n\n```java\npublic class SingletonLazy {\n    private static SingletonLazy instance;\n\n    private SingletonLazy() {}\n\n    public static SingletonLazy getInstance() {\n        if (instance == null) {\n            instance = new SingletonLazy();\n        }\n        return instance;\n    }\n}\n```\n\n### 3. 双重检查锁定 (Double-Checked Locking, DCL)\n\n对懒汉式的优化，兼顾了性能和线程安全。\n\n```java\npublic class SingletonDCL {\n    private static volatile SingletonDCL instance; // volatile 关键字是必须的\n\n    private SingletonDCL() {}\n\n    public static SingletonDCL getInstance() {\n        if (instance == null) { // 第一次检查\n            synchronized (SingletonDCL.class) {\n                if (instance == null) { // 第二次检查\n                    instance = new SingletonDCL();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 4. 静态内部类 (Static Inner Class)\n\n利用了 JVM 类加载机制来保证线程安全，是推荐的懒加载实现方式。\n\n```java\npublic class SingletonStaticInner {\n    private SingletonStaticInner() {}\n\n    private static class SingletonHolder {\n        private static final SingletonStaticInner INSTANCE = new SingletonStaticInner();\n    }\n\n    public static SingletonStaticInner getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n### 5. 枚举 (Enum)\n\n最简单、最安全的实现方式，能天然防止反射和反序列化攻击。\n\n```java\npublic enum SingletonEnum {\n    INSTANCE;\n\n    public void doSomething() {\n        System.out.println(\"Enum singleton is working.\");\n    }\n}\n```\n\n## UML 类图\n\n一个简单的类图包含一个 `Singleton` 类，它有一个私有的静态 `instance` 属性，一个私有的构造函数 `Singleton()`，以及一个公有的静态方法 `getInstance()`。\n\n## 优缺点\n\n- **优点**：\n  - 保证实例唯一，节约资源。\n  - 提供全局访问点。\n- **缺点**：\n  - 扩展性差，因为没有接口，继承困难。\n  - 违反了单一职责原则（既负责业务逻辑，又负责自我创建）。\n  - 在某些情况下（如DCL实现不当）可能存在线程安全问题。\n\n## 使用场景\n\n- 需要频繁创建和销毁的重量级对象，如数据库连接池、线程池。\n- 全局唯一的配置对象或工具类，如日志对象、ID生成器。\n- 网站的计数器等需要共享状态的场景。\n\n## 注意事项与常见问题\n\n- **反射攻击**：除了枚举方式，其他实现都可以通过反射调用私有构造函数来创建新实例。可以在构造函数中增加判断来防止。\n- **反序列化攻击**：如果单例类实现了 `Serializable` 接口，反序列化时会创建一个新实例。需要重写 `readResolve()` 方法来返回唯一的实例。\n\n## 在 Spring/Java 中的应用\n\n- **Spring 框架**：Spring 容器中的 Bean 默认就是单例作用域 (`@Scope(\"singleton\")`)。Spring 通过容器来管理这些单例，比手动实现更优雅、更强大。\n- **Java 运行时**：`java.lang.Runtime` 类就是使用饿汉式实现的单例。"
  },
  {
    "name": "工厂方法模式",
    "summary": "定义一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。",
    "notes": "# 工厂方法模式 (Factory Method Pattern)\n\n## 解决的问题\n\n当一个类不知道它所需要的对象的具体类型，或者希望由子类来指定所创建的对象时，工厂方法模式非常有用。它解决了以下问题：\n\n- **解耦创建者和产品**：将对象的创建过程从使用方（客户端）中分离出来，客户端只需要知道产品的抽象接口，而无需关心具体产品的创建细节。\n- **符合开闭原则**：当需要增加新的产品时，只需要增加一个新的具体工厂和具体产品类，而无需修改现有的工厂代码，扩展性好。\n\n## 核心思想与实现方式\n\n核心思想是定义一个抽象的工厂和抽象的产品，每个具体工厂负责创建一个具体的产品。\n\n**核心组件**：\n1.  **Product (抽象产品)**：定义产品对象的接口。\n2.  **ConcreteProduct (具体产品)**：实现 `Product` 接口。\n3.  **Factory (抽象工厂)**：声明工厂方法 `createProduct()`，其返回类型是 `Product`。\n4.  **ConcreteFactory (具体工厂)**：实现 `Factory` 接口，重写 `createProduct()` 方法以返回一个 `ConcreteProduct` 实例。\n\n### 示例代码\n\n```java\n// 1. 抽象产品\ninterface Logger {\n    void log(String message);\n}\n\n// 2. 具体产品\nclass FileLogger implements Logger { /* ... */ }\nclass DatabaseLogger implements Logger { /* ... */ }\n\n// 3. 抽象工厂\ninterface LoggerFactory {\n    Logger createLogger();\n}\n\n// 4. 具体工厂\nclass FileLoggerFactory implements LoggerFactory {\n    @Override\n    public Logger createLogger() {\n        return new FileLogger();\n    }\n}\n\nclass DatabaseLoggerFactory implements LoggerFactory {\n    @Override\n    public Logger createLogger() {\n        return new DatabaseLogger();\n    }\n}\n\n// 客户端使用\nLoggerFactory factory = new FileLoggerFactory();\nLogger logger = factory.createLogger();\nlogger.log(\"This is a test.\");\n```\n\n## UML 类图\n\n类图展示了四个角色：`Product` 接口和其实现 `ConcreteProduct`；`Factory` 接口（包含 `createProduct()` 方法）和其实现 `ConcreteFactory`。`ConcreteFactory` 的 `createProduct()` 方法返回一个 `ConcreteProduct` 实例。\n\n## 优缺点\n\n- **优点**：\n  - **良好的封装性**：客户端无需知道具体产品的类名，只需知道对应的工厂。\n  - **优秀的扩展性**：增加新产品时，符合开闭原则。\n  - **解耦**：将产品创建与使用分离。\n- **缺点**：\n  - 每增加一个产品，就需要增加一个对应的具体工厂类，导致类的数量成倍增加，增加了系统的复杂度。\n\n## 使用场景\n\n- 当一个类希望由其子类来指定它所创建的对象时。\n- 当你需要一个类库来提供一系列产品，但不想暴露产品的具体实现时。\n- 任何需要生成复杂对象的地方，都可以用工厂方法模式。特别是在需要统一管理对象创建过程的场景。\n\n## 注意事项与常见问题\n\n- **与简单工厂的区别**：简单工厂模式（一个工厂类根据参数创建不同产品）不属于 GoF 23 种设计模式，因为它不符合开闭原则。工厂方法模式将创建逻辑分散到各个具体工厂中，更具扩展性。\n- **与抽象工厂的区别**：工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构（一个产品族）。\n\n## 在 Spring/Java 中的应用\n\n- **Spring `FactoryBean`**：`FactoryBean` 接口是工厂方法模式的典型应用。实现该接口的 Bean 本身是一个工厂，`getObject()` 方法就是工厂方法，用于创建并返回一个由 Spring 管理的 Bean 实例。\n- **`java.util.Collection`** 的 `iterator()` 方法：`List`, `Set` 等集合类都实现了 `Collection` 接口，它们的 `iterator()` 方法就如同一个工厂方法，每个集合类都会返回一个适合自己的 `Iterator` 实现（如 `ArrayListIterator`）。"
  },
  {
    "name": "抽象工厂模式",
    "summary": "提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。",
    "notes": "# 抽象工厂模式 (Abstract Factory Pattern)\n\n## 解决的问题\n\n当系统需要处理多个产品族，且希望在不同产品族之间轻松切换时，抽象工厂模式非常有用。它解决了以下问题：\n\n- **产品族一致性**：确保客户端使用的所有产品都来自同一个产品族，避免混用不兼容的产品。\n- **隔离具体实现**：客户端代码只与抽象工厂和抽象产品接口交互，与具体产品的实现完全解耦。\n- **切换产品族**：更换具体工厂即可切换整个产品族，符合开闭原则。\n\n## 核心思想与实现方式\n\n核心思想是定义一个抽象工厂，它包含创建多个不同产品（属于同一族）的抽象方法。每个具体工厂实现这个抽象工厂，负责创建一整套具体的产品。\n\n**核心组件**：\n1.  **AbstractFactory (抽象工厂)**：声明一组用于创建抽象产品的接口。\n2.  **ConcreteFactory (具体工厂)**：实现 `AbstractFactory` 的接口，创建具体的产品族。\n3.  **AbstractProduct (抽象产品)**：为一类产品对象声明一个接口。\n4.  **ConcreteProduct (具体产品)**：实现 `AbstractProduct` 接口，由具体工厂创建。\n\n### 示例代码\n\n假设我们要创建一个支持不同操作系统（Windows/macOS）的 UI 组件库。\n\n```java\n// 抽象产品\ninterface Button { void render(); }\ninterface TextField { void display(); }\n\n// 具体产品 - Windows 族\nclass WinButton implements Button { /* ... */ }\nclass WinTextField implements TextField { /* ... */ }\n\n// 具体产品 - macOS 族\nclass MacButton implements Button { /* ... */ }\nclass MacTextField implements TextField { /* ... */ }\n\n// 抽象工厂\ninterface GUIFactory {\n    Button createButton();\n    TextField createTextField();\n}\n\n// 具体工厂 - Windows\nclass WinFactory implements GUIFactory {\n    public Button createButton() { return new WinButton(); }\n    public TextField createTextField() { return new WinTextField(); }\n}\n\n// 具体工厂 - macOS\nclass MacFactory implements GUIFactory {\n    public Button createButton() { return new MacButton(); }\n    public TextField createTextField() { return new MacTextField(); }\n}\n\n// 客户端使用\nGUIFactory factory = new MacFactory(); // 只需改变这一行，即可切换整个 UI 风格\nButton button = factory.createButton();\nTextField textField = factory.createTextField();\n```\n\n## UML 类图\n\n类图展示了两个层次的抽象：\n1.  工厂层次：`AbstractFactory` 和它的实现 `ConcreteFactory1`, `ConcreteFactory2`。\n2.  产品层次：`AbstractProductA`, `AbstractProductB` 和它们的具体实现 `ConcreteProductA1`, `ConcreteProductA2`, `ConcreteProductB1`, `ConcreteProductB2`。 `ConcreteFactory1` 创建 `ConcreteProductA1` 和 `ConcreteProductB1`。\n\n## 优缺点\n\n- **优点**：\n  - **产品族一致性**：保证了客户端使用的产品是配套的。\n  - **高内聚，低耦合**：将产品的创建和使用分离。\n  - **易于切换产品族**：更换具体工厂实现即可。\n- **缺点**：\n  - **难以扩展新产品**：如果要在产品族中增加一个新的产品（例如增加一个 Checkbox），需要修改抽象工厂和所有具体工厂的接口，违反了开闭原则。\n\n## 使用场景\n\n- 一个系统要独立于它的产品的创建、组合和表示时。\n- 一个系统要由多个产品系列中的一个来配置时。\n- 当你想要提供一个产品类库，而只想显示它们的接口而不是实现时。\n- 跨平台的 UI 工具包、数据库访问层（如 JDBC）。\n\n## 注意事项与常见问题\n\n- **适用性**：该模式适用于产品族相对稳定，不会频繁增加新产品的场景。如果产品种类需要经常变化，则不适合使用此模式。\n\n## 在 Spring/Java 中的应用\n\n- **JDBC (Java Database Connectivity)**：`java.sql.Connection` 是一个抽象工厂，它可以创建 `Statement`、`PreparedStatement` 等产品。不同的数据库驱动（如 MySQL Connector/J, PostgreSQL JDBC Driver）提供了 `Connection` 的具体实现，它们创建的 `Statement` 等对象就是与特定数据库兼容的具体产品。当你从 MySQL 切换到 PostgreSQL 时，只需更换驱动和连接字符串，`Connection` 对象就会由新的“具体工厂”创建，后续代码无需更改。"
  },
  {
    "name": "建造者模式",
    "summary": "将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。",
    "notes": "# 建造者模式 (Builder Pattern)\n\n## 解决的问题\n\n当一个对象的创建过程非常复杂，包含多个部分和步骤，且这些步骤的顺序或内容可能变化时，建造者模式非常有用。它解决了以下问题：\n\n- **构造函数参数过多**：避免出现拥有大量参数的构造函数，特别是当某些参数是可选的时候，可以避免创建多个重载构造函数。\n- **对象状态不一致**：在对象完全构建完成之前，防止其处于不完整或不一致的状态被外部访问。\n- **构建过程与表示分离**：允许同样的构建过程（由 `Director` 控制）创建出不同属性组合的对象（由 `ConcreteBuilder` 实现）。\n\n## 核心思想与实现方式\n\n核心思想是将对象的构建过程封装在一个 `Builder` 对象中，通过链式调用来一步步设置对象的属性，最后通过一个 `build()` 方法生成最终的对象。\n\n**经典实现（带 Director）**：\n1.  **Product (产品)**：要构建的复杂对象。\n2.  **Builder (抽象建造者)**：定义创建 `Product` 各个部分的抽象接口。\n3.  **ConcreteBuilder (具体建造者)**：实现 `Builder` 接口，完成复杂对象的具体构建步骤。\n4.  **Director (指挥者)**：负责调用 `Builder` 的方法来构建对象，它隔离了客户端与具体构建过程。\n\n**更现代的链式调用实现**：\n这是目前更流行、更简洁的实现方式，通常将 `Builder` 作为 `Product` 的一个静态内部类。\n\n### 示例代码 (链式调用)\n\n```java\n// Product\npublic class Computer {\n    private final String cpu;\n    private final String ram;\n    private final String storage;\n    private final String gpu; // 可选\n\n    private Computer(Builder builder) {\n        this.cpu = builder.cpu;\n        this.ram = builder.ram;\n        this.storage = builder.storage;\n        this.gpu = builder.gpu;\n    }\n\n    // Static inner Builder\n    public static class Builder {\n        private final String cpu; // 必选\n        private final String ram; // 必选\n        private String storage;\n        private String gpu;\n\n        public Builder(String cpu, String ram) {\n            this.cpu = cpu;\n            this.ram = ram;\n        }\n\n        public Builder storage(String storage) {\n            this.storage = storage;\n            return this; // 返回 this 实现链式调用\n        }\n\n        public Builder gpu(String gpu) {\n            this.gpu = gpu;\n            return this;\n        }\n\n        public Computer build() {\n            return new Computer(this);\n        }\n    }\n}\n\n// 客户端使用\nComputer gamingPC = new Computer.Builder(\"Intel i9\", \"32GB\")\n                             .storage(\"1TB SSD\")\n                             .gpu(\"NVIDIA RTX 4090\")\n                             .build();\n```\n\n## UML 类图\n\n经典模式的类图包含四个角色：`Director`, `Builder` 接口, `ConcreteBuilder` 实现和 `Product`。`Director` 持有 `Builder` 的引用，客户端通过 `Director` 来构建 `Product`。链式调用的实现则更简单，通常只有 `Product` 和其内部的 `Builder` 类。\n\n## 优缺点\n\n- **优点**：\n  - **封装性好**：客户端无需知道对象的内部组成和构建细节。\n  - **可读性高**：链式调用使得对象的属性设置清晰明了。\n  - **扩展性好**：增加新的构建步骤或新的 `ConcreteBuilder` 很方便。\n  - **参数控制灵活**：可以自由设置可选参数，并强制设置必选参数。\n- **缺点**：\n  - 会产生额外的 `Builder` 对象，增加了代码量。\n\n## 使用场景\n\n- 当创建的对象的属性很多，且有很多是可选的时候。\n- 当对象的创建过程依赖于多个部分，且这些部分的装配顺序需要控制时。\n- 需要创建不可变对象（Immutable Object）时，可以在 `build()` 方法中返回一个所有字段都是 `final` 的对象。\n\n## 注意事项与常见问题\n\n- **与工厂模式的区别**：建造者模式关注的是复杂对象的**分步构建过程**，允许客户端控制构建的细节；工厂模式关注的是**一次性创建**一个完整的对象，客户端不关心创建过程。\n\n## 在 Spring/Java 中的应用\n\n- **Lombok `@Builder`**：Lombok 库的 `@Builder` 注解会自动为类生成链式调用的建造者模式代码，极大简化了开发。\n- **`java.lang.StringBuilder`**：`StringBuilder` 的 `append()` 方法就是典型的链式调用，它是一个简单的建造者模式应用，用于构建字符串对象。\n- **Spring Framework**：`BeanDefinitionBuilder` 用于以编程方式构建 `BeanDefinition` 对象，`UriComponentsBuilder` 用于构建 URI。"
  },
  {
    "name": "原型模式",
    "summary": "使用一个原型实例指定创建对象的种类，并通过拷贝这个原型来创建新的对象。",
    "notes": "# 原型模式 (Prototype Pattern)\n\n## 解决的问题\n\n当创建一个对象的成本非常高时（例如，需要复杂的计算、数据库查询或网络I/O），或者当需要创建的对象与现有对象非常相似时，原型模式可以显著提高性能。它解决了以下问题：\n\n- **避免昂贵的创建成本**：通过复制现有对象来创建新对象，绕过了耗时的初始化过程。\n- **简化对象创建**：当一个系统需要独立于其产品的创建、组合和表示时，原型模式提供了一种替代构造函数的方式。\n\n## 核心思想与实现方式\n\n核心思想是让一个原型对象实现 `Cloneable` 接口，并重写 `clone()` 方法。客户端通过调用这个 `clone()` 方法来获得一个新的、与原型完全相同的对象副本。\n\n**核心组件**：\n1.  **Prototype (原型接口)**：声明一个 `clone()` 方法。在 Java 中，通常是实现 `java.lang.Cloneable` 接口。\n2.  **ConcretePrototype (具体原型类)**：实现 `Prototype` 接口，并重写 `Object` 类的 `clone()` 方法。\n\n### 示例代码\n\n```java\n// 具体原型类\nclass Sheep implements Cloneable {\n    private String name;\n    private int age;\n    private Friend friend; // 引用类型\n\n    public Sheep(String name, int age, Friend friend) {\n        this.name = name;\n        this.age = age;\n        this.friend = friend;\n    }\n\n    // Getters and Setters\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        // 默认是浅拷贝\n        return super.clone();\n    }\n}\n\nclass Friend { /* ... */ }\n\n// 客户端使用\nFriend friend = new Friend();\nSheep originalSheep = new Sheep(\"Dolly\", 3, friend);\n\n// 克隆\nSheep clonedSheep = (Sheep) originalSheep.clone();\n\nSystem.out.println(originalSheep.getFriend() == clonedSheep.getFriend()); // true，说明是浅拷贝\n```\n\n## UML 类图\n\n类图非常简单，包含一个 `Prototype` 接口（或实现了 `Cloneable` 的基类）和一个 `ConcretePrototype` 类。客户端持有一个 `Prototype` 的引用，并通过调用其 `clone()` 方法创建新对象。\n\n## 优缺点\n\n- **优点**：\n  - **性能高**：直接在内存中进行二进制流的拷贝，比执行 `new` 操作和构造函数更快。\n  - **简化创建过程**：可以动态地获取和设置要复制的对象。\n- **缺点**：\n  - **需要为每个类配备 `clone()` 方法**：对现有类的改造可能比较麻烦。\n  - **深拷贝与浅拷贝问题**：默认的 `clone()` 是浅拷贝，如果对象包含引用类型，只复制引用地址，这可能导致意外修改原始对象的数据。实现深拷贝需要额外的工作。\n\n## 使用场景\n\n- 类的实例化过程复杂或消耗大量资源。\n- 需要创建的对象与一个现有对象只有微小差异。\n- 一个类需要有多个修改版本，且每个版本都可能作为新对象的基础。\n\n## 注意事项与常见问题\n\n- **深拷贝 vs. 浅拷贝**：\n  - **浅拷贝 (Shallow Copy)**：只复制对象本身和其中的基本数据类型，对引用类型只复制其引用地址。新旧对象共享同一个引用对象。\n  - **深拷贝 (Deep Copy)**：在浅拷贝的基础上，对所有引用类型都递归地进行拷贝，直到所有对象都被复制一份。新旧对象完全独立。实现深拷贝通常需要手动对引用类型字段也调用 `clone()`，或者通过序列化/反序列化来实现。\n\n## 在 Spring/Java 中的应用\n\n- **Spring Bean 的原型作用域**：当一个 Bean 被声明为 `@Scope(\"prototype\")` 时，Spring 容器每次请求这个 Bean 都会创建一个新的实例。虽然其底层不一定是 `clone()` 实现，但其思想与原型模式一致：每次都提供一个新的对象副本，而不是共享一个单例。\n- **`java.util.ArrayList` 的 `clone()` 方法**：`ArrayList` 就实现了 `Cloneable` 接口，并提供了 `clone()` 方法来创建一个新的列表副本（这是一个浅拷贝）。"
  },
  {
    "name": "适配器模式",
    "summary": "将一个类的接口转换成客户端希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。",
    "notes": "# 适配器模式\n\n## 解决的问题 (What Problem It Solves)\n\n当你想使用一个已经存在的类，但它的接口不符合你的需求时，适配器模式可以解决这种**接口不兼容**的问题。它充当两个不兼容接口之间的桥梁，使得它们可以协同工作，而无需修改原有的代码。\n\n## 核心思想与实现方式 (Core Idea & Implementations)\n\n适配器模式的核心是引入一个“适配器”角色，它包装或继承一个已有的、不兼容的类（被适配者），并向客户端暴露一个符合其期望的接口（目标接口）。\n\n主要有两种实现方式：\n\n1.  **类适配器 (Class Adapter)**：通过**继承**被适配者类，并实现目标接口。这种方式下，适配器可以重写父类的方法。\n2.  **对象适配器 (Object Adapter)**：通过**组合**（持有）被适配者类的实例。这是更常用、更灵活的方式，因为它不依赖于具体的实现类，而是依赖于其接口。\n\n## UML 类图 (UML Class Diagram)\n\n- **Target (目标接口)**：客户端期望使用的接口。\n- **Client (客户端)**：与符合 Target 接口的对象协同工作。\n- **Adaptee (被适配者)**：一个已经存在的、接口不兼容的类。\n- **Adapter (适配器)**：它实现了 Target 接口，并持有一个 Adaptee 的实例（对象适配器）或继承自 Adaptee（类适配器），在内部将 Target 接口的调用转换为对 Adaptee 接口的调用。\n\n## 优缺点 (Pros and Cons)\n\n- **优点**：\n  - **增强复用性**：可以复用现有的、功能强大的类。\n  - **提高透明度**：客户端代码完全不知道适配器背后包装了其他类。\n  - **更好的灵活性和扩展性**：可以轻松地替换或增加新的适配器。\n- **缺点**：\n  - 过多使用适配器会让系统变得零散和复杂。\n  - 类适配器一次只能适配一个被适配者类，且有语言限制（如 Java 不支持多重继承）。\n\n## 使用场景 (Use Cases)\n\n- 集成遗留系统或第三方库，这些库的接口与当前系统不兼容。\n- 需要创建一个可以与多种不兼容类型协同工作的可复用类。\n- 例如，将一个旧的 XML 数据处理库适配成处理 JSON 的新接口。\n\n## 注意事项与常见问题 (Important Notes & Common Problems)\n\n- **与桥接模式的区别**：适配器模式是**事后补救**，解决两个已有接口不兼容的问题；桥接模式是**事前设计**，将抽象和实现分离，使它们可以独立变化。\n- **与装饰器模式的区别**：适配器模式改变对象的接口，而装饰器模式在不改变接口的前提下增强对象的功能。\n\n## 在 Spring/Java 中的应用 (Application in Spring/Java)\n\n- **Spring AOP**：Spring AOP 中使用适配器模式来适配不同类型的 `Advice`（如 `BeforeAdvice`, `AfterAdvice`）。\n- **Spring MVC**：`HandlerAdapter` 适配并执行不同类型的 `Handler`（如 `Controller` 方法）。\n- **Java I/O**：`java.io.InputStreamReader` 将字节流 `InputStream` 适配为字符流 `Reader`。\n- **SLF4J**：`slf4j-log4j12.jar` 就是一个适配器，它将 SLF4J 的日志接口适配到底层的 Log4j 实现。"
  },
  {
    "name": "装饰器模式",
    "summary": "动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。",
    "notes": "# 装饰器模式\n\n## 解决的问题 (What Problem It Solves)\n\n当你想为一个对象**动态地、透明地扩展功能**，但又不想通过创建大量子类来实现时，装饰器模式是理想的选择。它遵循开闭原则，允许在不修改原对象代码的情况下为其添加新行为。\n\n## 核心思想与实现方式 (Core Idea & Implementations)\n\n装饰器模式的核心是“包装”。创建一个装饰器类，它持有被装饰对象（组件）的引用，并与被装饰对象实现同一个接口。客户端使用装饰器时，感觉就像在使用原始对象，但装饰器在将请求转发给原始对象之前或之后，可以添加额外的逻辑。\n\n- 装饰器和被装饰对象必须有共同的超类或接口。\n- 装饰器可以一层层地嵌套，实现功能的叠加。\n\n## UML 类图 (UML Class Diagram)\n\n- **Component (组件接口)**：定义了原始对象和装饰器对象的统一接口。\n- **ConcreteComponent (具体组件)**：被装饰的原始对象。\n- **Decorator (抽象装饰器)**：继承自 Component，并持有一个 Component 对象的引用。它通常是一个抽象类。\n- **ConcreteDecorator (具体装饰器)**：负责向组件添加具体的职责。\n\n## 优缺点 (Pros and Cons)\n\n- **优点**：\n  - **高度灵活性**：比继承更灵活，可以动态地添加或删除功能。\n  - **遵循开闭原则**：可以在不修改现有代码的情况下扩展功能。\n  - **避免类爆炸**：相对于继承，可以避免因功能组合而产生大量子类。\n- **缺点**：\n  - 会产生很多细小的对象，增加系统的复杂性。\n  - 对于多层装饰，排错和调试可能比较困难。\n\n## 使用场景 (Use Cases)\n\n- 需要在运行时为一个对象动态添加功能，并且这些功能可以被撤销。\n- 当使用继承会导致子类数量爆炸时。\n- 例如，为一个咖啡订单（基础组件）添加不同的调料（牛奶、糖等装饰器）。\n\n## 注意事项与常见问题 (Important Notes & Common Problems)\n\n- **与代理模式的区别**：两者结构相似，但意图不同。装饰器模式的意图是**增强功能**，而代理模式的意图是**控制访问**。\n- **与适配器模式的区别**：装饰器模式不改变接口，只增强功能；适配器模式则主要用于转换接口。\n\n## 在 Spring/Java 中的应用 (Application in Spring/Java)\n\n- **Java I/O**：这是装饰器模式最经典的应用。`BufferedInputStream` 装饰了 `FileInputStream`，为其增加了缓冲功能；`GZIPInputStream` 装饰了其他输入流，增加了解压缩功能。\n- **Spring Session**：Spring Session 通过装饰 `HttpServletRequest` 来实现会话管理。\n- **MyBatis**：MyBatis 中的 `Cache` 模块也广泛使用了装饰器模式，如 `LruCache` 装饰了 `PerpetualCache` 增加了 LRU 淘汰策略。"
  },
  {
    "name": "代理模式",
    "summary": "为其他对象提供一种代理以控制对这个对象的访问。",
    "notes": "# 代理模式\n\n## 解决的问题 (What Problem It Solves)\n\n当你需要**控制对一个对象的访问**时，代理模式非常有用。它可以在不改变原始对象（被代理对象）代码的前提下，增加一些额外的逻辑，如权限校验、懒加载、日志记录、远程访问等。\n\n## 核心思想与实现方式 (Core Idea & Implementations)\n\n代理模式的核心是在客户端和目标对象之间引入一个“代理”对象。客户端不直接与目标对象交互，而是通过代理对象。代理对象和目标对象实现相同的接口，因此对客户端来说是透明的。\n\n实现方式：\n1.  **静态代理**：需要手动为每个目标类创建一个代理类，在编译期就已经确定。实现简单，但如果目标类增多，代理类也会爆炸式增长。\n2.  **动态代理**：在运行时动态地创建代理类，无需手动编写。主要有两种技术：\n    - **JDK 动态代理**：基于接口，要求目标对象必须实现一个或多个接口。\n    - **CGLIB 动态代理**：基于子类，通过继承目标类来创建代理，不要求目标类实现接口。\n\n## UML 类图 (UML Class Diagram)\n\n- **Subject (主题接口)**：定义了真实主题和代理主题的共同接口。\n- **RealSubject (真实主题)**：被代理的原始对象，定义了业务逻辑。\n- **Proxy (代理)**：持有 RealSubject 的引用，实现了 Subject 接口，并负责控制对 RealSubject 的访问。\n\n## 优缺点 (Pros and Cons)\n\n- **优点**：\n  - **职责清晰**：真实主题只关心业务逻辑，代理则负责非业务的控制逻辑。\n  - **高扩展性**：可以在不修改目标对象的情况下，灵活地增加新功能。\n  - **保护目标对象**：可以对访问进行过滤和控制。\n- **缺点**：\n  - 可能会增加系统的复杂性。\n  - 可能会因为增加了一层间接调用而导致请求处理速度变慢。\n\n## 使用场景 (Use Cases)\n\n- **远程代理 (Remote Proxy)**：为一个位于不同地址空间的对象提供本地代表，如 RPC 框架。\n- **虚拟代理 (Virtual Proxy)**：根据需要创建开销大的对象，如图片或大文件的懒加载。\n- **保护代理 (Protection Proxy)**：控制对原始对象的访问权限，如根据用户角色决定是否能调用某个方法。\n- **智能代理 (Smart Proxy)**：在访问对象时执行一些附加操作，如缓存、日志、事务管理。\n\n## 注意事项与常见问题 (Important Notes & Common Problems)\n\n- **与装饰器模式的区别**：代理模式主要用于**控制访问**，而装饰器模式用于**增强功能**。\n- **与适配器模式的区别**：代理模式的接口与目标对象一致，而适配器模式的接口与目标对象不一致。\n\n## 在 Spring/Java 中的应用 (Application in Spring/Java)\n\n- **Spring AOP**：Spring AOP 的核心就是动态代理。当一个 Bean 需要被切面增强时，Spring 会为它创建一个代理对象（JDK 或 CGLIB），在代理中织入通知（Advice）逻辑。\n- **Spring @Transactional**：事务管理也是通过代理实现的。当调用被 `@Transactional` 注解的方法时，实际上是调用了代理对象的方法，代理在方法执行前后开启和提交/回滚事务。\n- **RPC 框架**：如 Dubbo、gRPC 等，客户端调用的服务接口实际上是一个远程代理。"
  },
  {
    "name": "外观模式",
    "summary": "为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。",
    "notes": "# 外观模式\n\n## 解决的问题 (What Problem It Solves)\n\n当一个系统非常复杂，包含了大量的类和相互依赖时，客户端直接与这些底层组件交互会非常困难和混乱。外观模式通过提供一个**简化的、统一的入口**，隐藏了系统的复杂性，使得客户端可以更容易地使用该系统。\n\n## 核心思想与实现方式 (Core Idea & Implementations)\n\n核心是创建一个“外观”类（Facade）。这个类封装了对子系统中多个复杂组件的调用逻辑，并向外提供一个或多个简洁的高层方法。客户端只需要与这个外观类交互，而无需关心底层子系统的内部实现细节。\n\n- 外观类知道如何协调子系统中的各个组件来完成一个任务。\n- 它将客户端与子系统解耦，降低了耦合度。\n\n## UML 类图 (UML Class Diagram)\n\n- **Facade (外观)**：定义了一个高层接口，它知道如何将客户端的请求委派给相应的子系统对象。\n- **Subsystem Classes (子系统类)**：实现了子系统的功能，处理由 Facade 对象指派的任务。它们对外观一无所知。\n- **Client (客户端)**：通过 Facade 与子系统交互。\n\n## 优缺点 (Pros and Cons)\n\n- **优点**：\n  - **简化接口**：让客户端更容易使用复杂的子系统。\n  - **降低耦合**：将客户端与子系统的实现解耦，子系统的变化不会影响到客户端。\n  - **提高安全性**：可以只暴露子系统的一部分功能给外部。\n- **缺点**：\n  - 不符合开闭原则。如果需要修改外观提供的功能，通常需要修改外观类的代码。\n  - 外观类可能会变成一个“上帝对象”，承担过多的职责。\n\n## 使用场景 (Use Cases)\n\n- 当你需要为一个复杂的子系统提供一个简单的接口时。\n- 当客户端与多个子系统之间存在大量的依赖关系时，引入外观可以简化这种关系。\n- 当你需要对系统进行分层时，外观可以作为每一层的入口。\n\n## 注意事项与常见问题 (Important Notes & Common Problems)\n\n- 外观模式并不限制客户端直接访问子系统。如果需要，客户端仍然可以绕过外观，直接与底层组件交互。外观只是提供了一条“便捷通道”。\n- 一个系统可以有多个外观类，每个外观类针对不同的客户端需求。\n\n## 在 Spring/Java 中的应用 (Application in Spring/Java)\n\n- **SLF4J**：`LoggerFactory.getLogger()` 是一个典型的外观。它隐藏了背后复杂的日志框架发现和绑定机制，为用户提供了一个极其简单的获取 Logger 的方法。\n- **Spring JDBC**：`JdbcTemplate` 封装了繁琐的 JDBC 操作（如创建连接、创建 Statement、处理异常、关闭资源），为开发者提供了一套简洁的数据访问接口。\n- **MyBatis**：`SqlSessionFactory` 也是一个外观，它封装了配置解析、环境构建、事务管理等复杂过程。\n- **Tomcat**：Tomcat 的 `RequestFacade` 和 `ResponseFacade` 也是外观模式的应用，它们为 Servlet 提供了对内部 `Request` 和 `Response` 对象的受限访问。"
  },
  {
    "name": "桥接模式",
    "summary": "将抽象部分与它的实现部分分离，使它们都可以独立地变化。",
    "notes": "# 桥接模式\n\n## 解决的问题 (What Problem It Solves)\n\n当一个事物存在**多个独立变化的维度**时，如果使用继承来实现，会导致类的数量呈指数级增长，即“类爆炸”。桥接模式通过将这些维度分离，并用组合关系取代继承关系，来解决这个问题，使得每个维度都可以独立扩展。\n\n## 核心思想与实现方式 (Core Idea & Implementations)\n\n桥接模式的核心思想是**“分离抽象与实现”**。\n- **抽象部分 (Abstraction)**：定义了高层逻辑的接口，它持有一个“实现部分”的引用。\n- **实现部分 (Implementor)**：定义了底层功能的接口，它不关心高层逻辑。\n\n通过这种方式，抽象部分的变化和实现部分的变化可以完全独立，互不影响。例如，“形状”是一个抽象维度，它可以是圆形、方形；“颜色”是另一个实现维度，可以是红色、蓝色。桥接模式允许你独立地增加新的形状或新的颜色，而无需为每种组合创建一个新类（如 RedCircle, BlueSquare）。\n\n## UML 类图 (UML Class Diagram)\n\n- **Abstraction (抽象类)**：定义了抽象接口，并维护一个指向 Implementor 的引用。\n- **RefinedAbstraction (扩充抽象类)**：扩展 Abstraction，实现高层业务逻辑。\n- **Implementor (实现者接口)**：定义了实现类的接口，供 Abstraction 调用。\n- **ConcreteImplementor (具体实现者)**：实现了 Implementor 接口。\n\n## 优缺点 (Pros and Cons)\n\n- **优点**：\n  - **分离抽象和实现**：使两者可以独立演化，极大提高了系统的扩展性。\n  - **避免类爆炸**：有效地控制了类的数量。\n  - **符合单一职责和开闭原则**。\n- **缺点**：\n  - 增加了系统的理解和设计难度。\n  - 需要在一开始就识别出系统中独立变化的维度。\n\n## 使用场景 (Use Cases)\n\n- 当一个类存在两个或多个独立变化的维度，且这些维度都需要独立扩展时。\n- 当你不希望在抽象和实现之间形成固定的绑定关系时（不使用继承）。\n- 例如，一个支付应用，支付方式（抽象：如密码支付、指纹支付）和支付渠道（实现：如支付宝、微信支付）是两个独立变化的维度。\n\n## 注意事项与常见问题 (Important Notes & Common Problems)\n\n- **与适配器模式的区别**：桥接模式的意图是**分离**，用于系统设计之初；而适配器模式的意图是**兼容**，用于解决已有接口不匹配的问题。\n- 桥接模式的核心在于“解耦”，让抽象和实现沿着各自的轴线自由变化。\n\n## 在 Spring/Java 中的应用 (Application in Spring/Java)\n\n- **JDBC**：这是桥接模式最经典的案例。Java 提供了统一的 `java.sql.Driver` 接口（实现者接口），而上层应用通过 `DriverManager` 或 `DataSource` (抽象部分) 来使用它。具体的数据库厂商（MySQL, Oracle）提供各自的 `Driver` 实现（具体实现者）。应用代码完全与具体的数据库驱动实现解耦，可以轻松切换数据库。\n- **AWT (早期)**：早期的 AWT 使用桥接模式来连接 Java 的 UI 组件和不同操作系统的原生 UI 组件。"
  },
  {
    "name": "组合模式",
    "summary": "将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。",
    "notes": "# 组合模式\n\n## 解决的问题 (What Problem It Solves)\n\n当你需要处理一个具有**树形结构**的对象集合，并且希望像对待单个对象一样，统一地对待整个集合或集合中的一部分时，组合模式非常适用。它模糊了简单元素（叶子节点）和复杂元素（容器节点）的区别，让客户端可以一致地处理它们。\n\n## 核心思想与实现方式 (Core Idea & Implementations)\n\n组合模式的核心是定义一个统一的组件接口，让叶子节点和容器节点都实现这个接口。容器节点内部持有一个组件对象的集合（可以是叶子，也可以是其他容器），并将针对容器的操作委托给其所有子组件执行。\n\n实现方式：\n1.  **透明模式**：在统一的组件接口中声明所有管理子对象的方法（如 `add`, `remove`）。这样客户端无需区分叶子和容器，但叶子节点需要对这些方法提供空实现或抛出异常。\n2.  **安全模式**：只在容器节点的类中声明管理子对象的方法。这样客户端代码在调用前需要判断对象类型，但接口更安全，叶子节点不会有多余的方法。\n\n## UML 类图 (UML Class Diagram)\n\n- **Component (组件)**：为组合中的对象声明一个统一接口，包含叶子和容器的公共行为。\n- **Leaf (叶子)**：表示组合中的叶子对象，它没有子节点。\n- **Composite (容器/组合)**：表示组合中的容器对象，它可以包含子节点（Leaf 或 Composite）。它实现了在 Component 接口中定义的、与子组件相关的操作。\n\n## 优缺点 (Pros and Cons)\n\n- **优点**：\n  - **简化客户端代码**：客户端可以一致地处理所有对象，无需区分是叶子还是容器。\n  - **易于扩展**：可以很方便地增加新的组件（叶子或容器）类型。\n- **缺点**：\n  - 在安全模式下，客户端代码需要进行类型判断，增加了复杂性。\n  - 在透明模式下，设计不够安全，叶子节点被迫实现不相关的方法。\n\n## 使用场景 (Use Cases)\n\n- 任何需要表示“部分-整体”的层次结构，如：\n  - 文件系统：目录（容器）和文件（叶子）。\n  - 公司组织架构：部门（容器）和员工（叶子）。\n  - GUI 界面：窗口、面板（容器）和按钮、文本框（叶子）。\n\n## 注意事项与常见问题 (Important Notes & Common Problems)\n\n- 组合模式的本质在于递归组合，容器的操作会递归地传递给其所有子组件。\n- 设计时需要在“透明性”和“安全性”之间做出权衡。\n\n## 在 Spring/Java 中的应用 (Application in Spring/Java)\n\n- **AWT/Swing**：`java.awt.Container` 和 `java.awt.Component` 是典型的组合模式应用。一个 `Container` 可以包含多个 `Component`，而 `Container` 本身也是一个 `Component`。\n- **Web 框架的视图**：许多 Web 框架中的视图组件也构成了树形结构。\n- **Map/Set 接口**：`Map.putAll()` 方法也体现了组合模式的思想，它允许你将一个 `Map` (组合) 当作单个元素添加到另一个 `Map` 中。"
  },
  {
    "name": "享元模式",
    "summary": "运用共享技术有效地支持大量细粒度的对象，以减少内存消耗和提高性能。",
    "notes": "# 享元模式\n\n## 解决的问题 (What Problem It Solves)\n\n当一个应用程序需要创建**大量相似的对象**，导致内存占用过高，甚至引发内存溢出时，享元模式提供了一种解决方案。它通过共享尽可能多的对象来最小化内存使用。\n\n## 核心思想与实现方式 (Core Idea & Implementations)\n\n享元模式的核心思想是区分对象的**内部状态 (Intrinsic State)** 和**外部状态 (Extrinsic State)**。\n\n- **内部状态**：可以被共享的、不随外部环境改变的部分。例如，一个字符的字形、字体、大小。\n- **外部状态**：不可以被共享的、随外部环境改变的部分。例如，一个字符在文档中的位置、颜色。\n\n享元模式将内部状态封装在“享元对象”中，并由一个“享元工厂”来管理和缓存这些对象。当客户端需要一个对象时，它首先向工厂请求。如果工厂中已存在具有相同内部状态的享元对象，则直接返回共享的实例；否则，创建一个新的实例，存入工厂并返回。外部状态由客户端在调用享元对象的方法时传入。\n\n## UML 类图 (UML Class Diagram)\n\n- **Flyweight (抽象享元)**：定义了享元对象的接口，通常包含一个操作方法，该方法接受外部状态作为参数。\n- **ConcreteFlyweight (具体享元)**：实现了 Flyweight 接口，封装了内部状态。\n- **UnsharedConcreteFlyweight (非共享具体享元)**：一些不能被共享的子类，通常由客户端直接创建和管理。\n- **FlyweightFactory (享元工厂)**：负责创建和管理享元对象池，确保对象被共享。\n- **Client (客户端)**：维护一个对享元的引用，并计算或存储享元的外部状态。\n\n## 优缺点 (Pros and Cons)\n\n- **优点**：\n  - **大幅减少内存占用**：通过共享对象，显著降低了系统中对象的数量。\n  - **提高性能**：减少了对象创建和垃圾回收的开销。\n- **缺点**：\n  - **增加了系统复杂性**：需要分离内外状态，并引入工厂类，使得系统逻辑更复杂。\n  - **外部状态管理**：客户端需要自己管理外部状态，这可能会带来额外的开销和复杂性。\n\n## 使用场景 (Use Cases)\n\n- 系统中有大量相同或相似的对象。\n- 对象的多数状态可以外部化。\n- 对象创建的代价很高，且主要成本由其内部状态决定。\n- 例如，文本编辑器中的字符、围棋或五子棋的棋子、数据库连接池中的连接对象。\n\n## 注意事项与常见问题 (Important Notes & Common Problems)\n\n- 享元模式是一种以时间换空间的优化方案。客户端需要花费额外时间来管理外部状态。\n- 享元对象必须是线程安全的，因为它们可能被多个客户端并发访问。\n\n## 在 Spring/Java 中的应用 (Application in Spring/Java)\n\n- **Java `String` 池**：字符串常量池是享元模式最典型的应用。相同的字符串字面量在内存中只有一份拷贝。\n- **Java 包装类**：`Integer.valueOf(int i)`、`Long.valueOf(long l)` 等方法，对于一定范围内的数值（如 Integer 的 -128 到 127），会缓存并返回同一个对象实例。\n- **数据库连接池**：连接池中的每个连接对象都可以被看作是享元对象，它们被多个业务请求线程共享使用。"
  },
  {
    "name": "策略模式",
    "summary": "定义一系列算法，将它们一个个封装起来，并使它们可以相互替换。此模式让算法的变化独立于使用算法的客户。",
    "notes": "# 策略模式\n\n## 解决的问题\n当系统中存在多种相似的算法或行为，并且需要在运行时根据不同情况动态选择其中一种时，使用策略模式可以避免冗长的 `if-else` 或 `switch-case` 结构，使系统更加灵活和易于扩展。\n\n## 核心思想与实现方式\n1.  **定义一个策略接口 (Strategy)**：该接口声明了所有具体策略类需要实现的公共方法。\n2.  **创建多个具体策略类 (Concrete Strategy)**：每个类实现策略接口，封装一种具体的算法或行为。\n3.  **创建一个上下文类 (Context)**：该类持有一个策略接口的引用。它不直接执行算法，而是将工作委托给引用的策略对象。上下文类提供一个方法来更换策略对象。\n4.  **客户端 (Client)**：客户端创建具体的策略对象，并将其设置到上下文对象中，从而在运行时改变上下文的行为。\n\n## UML 类图\n- **Context**: 维护一个对 `Strategy` 对象的引用，并定义一个接口让 `Strategy` 来执行算法。\n- **Strategy**: 定义所有支持的算法的公共接口。\n- **ConcreteStrategyA / ConcreteStrategyB**: 实现 `Strategy` 接口，封装具体的算法。\n\n## 优缺点\n\n- **优点**：\n  - 遵循开闭原则，易于扩展新的策略，无需修改现有代码。\n  - 避免了多重条件判断，代码更清晰。\n  - 每个策略都是独立的类，易于单元测试和复用。\n- **缺点**：\n  - 策略类的数量会增加，可能导致类爆炸。\n  - 客户端必须了解所有策略的区别，并自行决定使用哪一个。\n\n## 使用场景\n- 一个系统需要动态地在几种算法中选择一种。\n- 一个对象有很多行为，而这些行为在运行时根据状态变化。可以把这些行为封装成独立的策略。\n- 需要屏蔽算法的具体实现细节。\n\n## 注意事项与常见问题\n- **与状态模式的区别**：\n  - **目的不同**：策略模式旨在封装可互换的算法；状态模式旨在根据内部状态改变对象的行为。\n  - **行为改变方式不同**：策略模式中，由客户端主动选择和更换策略；状态模式中，状态的切换通常是对象内部的自发行为，对客户端透明。\n\n## 在 Spring/Java 中的应用\n- `java.util.Comparator`：`Collections.sort()` 方法接受一个 `Comparator` 对象作为参数，这就是一个策略，决定了不同的排序方式。\n- **Spring 资源加载**：Spring 的 `ResourceLoader` 可以根据不同的前缀（如 `classpath:`, `file:`）返回不同的 `Resource` 实现（`ClassPathResource`, `FileSystemResource`），这些实现就是不同的资源加载策略。\n- **Spring Security**：`PasswordEncoder` 接口有多种实现（`BCryptPasswordEncoder`, `SCryptPasswordEncoder`），应用可以根据安全需求选择不同的密码加密策略。"
  },
  {
    "name": "模板方法模式",
    "summary": "在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中实现。此模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。",
    "notes": "# 模板方法模式\n\n## 解决的问题\n当多个类中存在完全相同或相似的算法流程，但其中某些步骤的具体实现又各不相同时，可以使用模板方法模式。它将重复的流程代码提取到父类中，避免代码冗余。\n\n## 核心思想与实现方式\n1.  **创建抽象父类 (Abstract Class)**：定义一个“模板方法”（通常声明为 `final` 以防止被重写），该方法定义了算法的执行流程，并调用一系列基本操作（`primitive operations`）。\n2.  **定义基本操作**：在抽象父类中，定义若干个基本操作。这些操作可以是：\n    - **抽象方法**：强制子类必须实现。\n    - **具体方法**：子类可以继承或重写。\n    - **钩子方法 (Hook Method)**：父类提供一个空的或默认的实现，子类可以选择性地重写它来影响算法流程。\n3.  **创建具体子类 (Concrete Class)**：继承抽象父类，并重写父类中定义的抽象方法或钩子方法，以完成算法中与自身相关的特定步骤。\n\n## UML 类图\n- **AbstractClass**: 包含 `templateMethod()` 和一个或多个抽象的 `primitiveOperation()`。\n- **ConcreteClass**: 继承自 `AbstractClass`，并实现 `primitiveOperation()`。\n\n## 优缺点\n- **优点**：\n  - 封装了不变部分，扩展了可变部分，提高了代码复用性。\n  - 行为由父类控制，子类实现细节，符合开闭原则。\n  - 便于维护，修改公共流程只需在父类中进行。\n- **缺点**：\n  - 每个不同的实现都需要一个子类，可能导致类的数量增加。\n  - 父类与子类之间存在较强的耦合，因为子类的执行受父类模板的约束。\n\n## 使用场景\n- 多个子类有共有的方法，并且逻辑基本相同。\n- 重要的、复杂的算法，希望核心流程固定，但允许子类对某些步骤进行定制。\n- 需要重构丑陋的 `if-else` 结构，将不同条件下的行为分离到不同的子类中。\n\n## 注意事项与常见问题\n- **钩子方法的妙用**：钩子方法是模板方法模式中非常灵活的一个工具。它让子类有能力影响父类的行为，但不是强制性的。例如，模板方法中可以根据钩子方法的返回值来决定是否执行某个步骤。\n\n## 在 Spring/Java 中的应用\n- **Java 集合框架**：`java.util.AbstractList`、`java.util.AbstractSet` 等抽象集合类提供了基础的集合操作的模板，如 `addAll`, `equals`, `hashCode`，而将 `get`, `size` 等核心方法定义为抽象的，由具体子类（如 `ArrayList`, `HashSet`）实现。\n- **Spring框架**：`JdbcTemplate`, `RedisTemplate`, `JmsTemplate` 等都是模板方法模式的经典应用。它们封装了资源获取、异常处理、资源释放等固定流程，而将具体的数据处理逻辑（如 `RowMapper`）交给用户通过回调函数来实现。"
  },
  {
    "name": "观察者模式",
    "summary": "定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知并自动更新。",
    "notes": "# 观察者模式\n\n## 解决的问题\n当一个对象（主题）的状态变化需要通知其他多个对象（观察者），但又不希望主题与观察者之间形成紧密耦合时。它实现了发布-订阅（Publish-Subscribe）模型，使得消息的发送方和接收方可以独立变化。\n\n## 核心思想与实现方式\n1.  **定义主题接口 (Subject)**：包含三个核心方法：注册观察者 (`registerObserver`)、移除观察者 (`removeObserver`) 和通知所有观察者 (`notifyObservers`)。\n2.  **定义观察者接口 (Observer)**：包含一个更新方法 (`update`)，当接收到主题的通知时，该方法被调用。\n3.  **创建具体主题类 (Concrete Subject)**：实现主题接口，维护一个观察者列表。当自身状态发生变化时，调用 `notifyObservers()` 方法，遍历列表并调用每个观察者的 `update()` 方法。\n4.  **创建具体观察者类 (Concrete Observer)**：实现观察者接口，定义在接收到通知后需要执行的具体操作。\n\n## UML 类图\n- **Subject**: 定义了注册、移除和通知观察者的方法。\n- **ConcreteSubject**: 实现了 `Subject` 接口，维护观察者列表并管理自身状态。\n- **Observer**: 定义了一个 `update()` 方法，供 `Subject` 在状态变化时调用。\n- **ConcreteObserver**: 实现了 `Observer` 接口，定义了具体的更新逻辑。\n\n## 优缺点\n- **优点**：\n  - 主题和观察者之间是松耦合的，双方只知道对方实现了某个接口，不关心具体实现。\n  - 支持广播通信，一个主题可以通知任意数量的观察者。\n  - 遵循开闭原则，增加新的观察者无需修改主题代码。\n- **缺点**：\n  - 如果观察者数量过多，通知所有观察者会比较耗时。\n  - 如果存在循环依赖，可能导致系统崩溃。\n  - 主题只管通知，不关心观察者是否接收成功。\n\n## 使用场景\n- 一个对象的改变需要同时改变其他对象，但不知道具体有多少对象需要改变。\n- 一个对象必须通知其他对象，但它又不能对那些对象做出任何假设。\n- 跨系统的事件驱动架构，如消息队列。\n\n## 注意事项与常见问题\n- **推模型 vs. 拉模型**：\n  - **推模型 (Push)**：主题在通知时，将变化的数据作为参数直接推送给观察者。优点是观察者被动接收，简单；缺点是如果数据量大或观察者不需要所有数据，会造成浪费。\n  - **拉模型 (Pull)**：主题只通知观察者“状态已变”，观察者自己决定何时以及从主题中拉取哪些数据。优点是更灵活；缺点是观察者需要持有主题的引用。\n\n## 在 Spring/Java 中的应用\n- **Java AWT/Swing 事件监听**：`ActionListener` 就是一个典型的观察者模式应用，按钮 (`JButton`) 是主题，监听器是观察者。\n- **Spring 事件机制**：`ApplicationEvent` 和 `ApplicationListener` 是 Spring 框架中观察者模式的实现。通过 `ApplicationContext` 的 `publishEvent()` 方法发布事件（主题状态变化），所有监听该事件的 `ApplicationListener`（观察者）都会被触发。\n- **消息队列**：如 RabbitMQ、Kafka 的发布-订阅模式，是观察者模式在分布式系统中的一种体现。"
  },
  {
    "name": "责任链模式",
    "summary": "为请求创建了一个接收者对象的链。此模式让请求的发送者和接收者解耦，请求沿着链传递，直到有一个对象处理它为止。",
    "notes": "# 责任链模式\n\n## 解决的问题\n当一个请求的处理器不确定，或者有多个对象都有机会处理该请求时，使用责任链模式可以避免将请求的发送者与接收者硬编码耦合在一起。同时，也支持在运行时动态地组织和修改处理链。\n\n## 核心思想与实现方式\n1.  **定义处理器接口 (Handler)**：该接口通常包含两个部分：一个处理请求的方法 (`handleRequest`) 和一个设置下一个处理器的方法 (`setNext`)。\n2.  **创建具体处理器类 (Concrete Handler)**：实现处理器接口。在其 `handleRequest` 方法中，首先判断自己能否处理该请求。如果能，就处理它；如果不能，就将其传递给链中的下一个处理器（通过调用 `next.handleRequest()`）。\n3.  **客户端 (Client)**：客户端负责创建处理器链，即创建多个处理器对象，并通过 `setNext` 方法将它们连接起来。然后，客户端只需将请求发送给链的第一个处理器即可。\n\n## UML 类图\n- **Handler**: 定义处理请求的接口和设置后继者的方法。\n- **ConcreteHandlerA / ConcreteHandlerB**: 实现 `Handler` 接口，处理它们负责的请求，并将其他请求转发给后继者。\n\n## 优缺点\n- **优点**：\n  - **降低耦合度**：请求的发送者无需知道是哪个对象处理了它的请求，接收者也无需知道发送者。\n  - **增强灵活性**：可以随时增加、删除或重组链中的处理器，符合开闭原则。\n  - **职责单一**：每个处理器都只关心自己的职责范围，符合单一职责原则。\n- **缺点**：\n  - **性能问题**：如果链条过长，或者每个处理器的判断逻辑复杂，可能会影响性能。\n  - **不保证被处理**：请求有可能遍历完整个链条都未被任何处理器处理。\n  - **调试不便**：链条的动态组合可能给调试带来困难。\n\n## 使用场景\n- 有多个对象可以处理同一个请求，但具体由哪个对象处理是在运行时动态决定的。\n- 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。\n- 需要动态指定一组对象来处理请求。\n\n## 注意事项与常见问题\n- **纯链与不纯链**：\n  - **纯责任链**：一个处理器要么完全处理请求（并中断链），要么就完全不处理，将其完整地传递给下一个。请求只被一个处理器消费。\n  - **不纯责任链**：一个处理器可以处理请求的一部分，然后继续将其传递给下一个处理器，让后续处理器也能处理。请求可以被多个处理器消费。\n\n## 在 Spring/Java 中的应用\n- **Java Servlet Filter 链**：Web 应用中的每个 HTTP 请求都会经过一个 `Filter` 链。每个 `Filter` 都可以对请求进行处理（如编码、认证），然后决定是否调用 `chain.doFilter()` 将请求传递给下一个 `Filter` 或最终的 `Servlet`。这是典型的不纯责任链。\n- **Spring Security 过滤器链**：Spring Security 使用一个过滤器链 (`FilterChain`) 来处理认证和授权。请求会依次通过如 `CsrfFilter`, `UsernamePasswordAuthenticationFilter` 等多个过滤器。\n- **MyBatis 插件**：MyBatis 的插件机制（`Interceptor`）也是基于责任链模式实现的，允许用户在 SQL 执行的多个关键点（如参数处理、结果集处理）插入自定义逻辑。"
  },
  {
    "name": "命令模式",
    "summary": "将一个请求封装成一个对象，从而可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。",
    "notes": "# 命令模式\n\n## 解决的问题\n将请求的“调用方”与“接收方”（即请求的实际执行者）解耦。在需要将操作抽象化，支持队列、日志、撤销/重做等功能的场景下非常有用。\n\n## 核心思想与实现方式\n1.  **定义命令接口 (Command)**：通常只包含一个执行方法，如 `execute()`。\n2.  **创建具体命令类 (Concrete Command)**：实现命令接口。它内部持有一个“接收者”对象的引用。在 `execute()` 方法中，它会调用接收者的一个或多个具体方法来完成操作。\n3.  **创建接收者类 (Receiver)**：这是真正执行业务逻辑的类，它知道如何执行与请求相关的操作。\n4.  **创建调用者类 (Invoker)**：调用者持有一个命令对象。它不关心命令的具体内容和接收者是谁，只在需要时调用命令对象的 `execute()` 方法。\n5.  **客户端 (Client)**：客户端负责创建具体命令对象，并设置其接收者。然后将命令对象传递给调用者。\n\n## UML 类图\n- **Command**: 声明执行操作的接口。\n- **ConcreteCommand**: 实现 `Command` 接口，定义了 `Receiver` 和一个动作之间的绑定关系。\n- **Receiver**: 知道如何实施与执行一个请求相关的操作。\n- **Invoker**: 要求该命令执行这个请求。\n- **Client**: 创建一个 `ConcreteCommand` 对象并设定它的 `Receiver`。\n\n## 优缺点\n- **优点**：\n  - **解耦**：完全解耦了请求的调用者和执行者。\n  - **易于扩展**：增加新的命令非常容易，只需创建一个新的具体命令类即可，符合开闭原则。\n  - **支持高级功能**：可以方便地实现命令队列、宏命令（组合多个命令）、以及撤销（`unexecute`）和重做功能。\n- **缺点**：\n  - 如果系统中有大量操作，可能会导致创建非常多的具体命令类，增加系统的复杂性。\n\n## 使用场景\n- 当需要将操作抽象化，并以参数形式传递时（例如，`Runnable`）。\n- 在不同的时间点和地点指定、排列和执行请求，例如任务队列。\n- 需要支持撤销/重做操作。\n- 需要将执行操作的对象与实现该操作的对象解耦。\n\n## 注意事项与常见问题\n- **命令模式的本质**：其本质是封装请求，将请求本身变成一个对象。这使得请求可以像其他任何对象一样被存储、传递和操作。\n- **空命令对象 (Null Command)**：可以定义一个什么都不做的空命令对象，作为默认值或用于简化处理，避免 `null` 检查。\n\n## 在 Spring/Java 中的应用\n- **`java.lang.Runnable`**：`Runnable` 接口本身就是一个命令模式的体现。`Runnable` 对象封装了一个待执行的任务 (`run()` 方法)，而 `Thread` 类就是调用者，它接收 `Runnable` 对象并执行它。\n- **GUI 编程**：图形界面中按钮的点击事件处理。`Button` 是调用者，`ActionListener` 的实现类是具体命令，`ActionListener` 接口是命令接口。\n- **Spring `JdbcTemplate`**：`JdbcTemplate` 的 `execute(StatementCallback<T> action)` 方法，`StatementCallback` 接口及其匿名实现就扮演了命令的角色，封装了具体的数据库操作。"
  },
  {
    "name": "迭代器模式",
    "summary": "提供一种方法顺序访问一个聚合对象（如列表、集合）中的各个元素，而又无需暴露该对象的内部表示。",
    "notes": "# 迭代器模式\n\n## 解决的问题\n为各种不同的数据结构（如数组、列表、树等）提供一个统一的遍历接口。客户端无需关心数据结构的内部实现细节，就可以用同样的方式遍历它们，从而实现了数据结构与遍历算法的解耦。\n\n## 核心思想与实现方式\n1.  **定义迭代器接口 (Iterator)**：包含遍历所需的核心方法，如 `hasNext()`（判断是否还有下一个元素）和 `next()`（获取下一个元素）。有时也包含 `remove()` 方法。\n2.  **定义聚合接口 (Aggregate)**：包含一个创建迭代器的方法，如 `createIterator()`，返回一个 `Iterator` 对象。\n3.  **创建具体迭代器类 (Concrete Iterator)**：实现迭代器接口，负责实际的遍历逻辑，并记录当前遍历的位置。\n4.  **创建具体聚合类 (Concrete Aggregate)**：实现聚合接口，存储数据集合，并实现 `createIterator()` 方法，返回一个针对自身数据结构的具体迭代器实例。\n\n## UML 类图\n- **Iterator**: 定义访问和遍历元素的接口。\n- **ConcreteIterator**: 实现 `Iterator` 接口，并对 `Aggregate` 进行遍历，跟踪当前遍历位置。\n- **Aggregate**: 定义创建相应迭代器对象的接口。\n- **ConcreteAggregate**: 实现 `Aggregate` 接口，返回一个 `ConcreteIterator` 的实例。\n\n## 优缺点\n- **优点**：\n  - **封装性**：隐藏了聚合对象的内部结构，客户端代码更加简洁。\n  - **单一职责**：将数据存储和数据遍历的职责分离开来。\n  - **统一接口**：为不同的聚合结构提供了统一的遍历方式。\n  - **支持多种遍历方式**：一个聚合对象可以有多个不同的迭代器实现（如正序、逆序）。\n- **缺点**：\n  - 对于简单的数据结构，引入迭代器模式可能会增加类的数量，使系统变得更复杂。\n\n## 使用场景\n- 当你需要访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候。\n- 当你需要对聚合对象提供多种遍历方式时。\n- 为遍历不同的聚合结构提供一个统一的接口。\n\n## 注意事项与常见问题\n- **遍历时的修改问题 (ConcurrentModificationException)**：当使用迭代器遍历一个集合时，如果同时通过集合本身的方法（而不是迭代器的 `remove()` 方法）修改了集合的结构（增、删元素），通常会抛出 `ConcurrentModificationException`。这是 Java 集合框架中的一种“快速失败”（fail-fast）机制。\n\n## 在 Spring/Java 中的应用\n- **Java 集合框架 (Java Collections Framework)**：这是迭代器模式最经典和广泛的应用。所有 `java.util.Collection` 接口的实现类（如 `ArrayList`, `LinkedList`, `HashSet`）都实现了 `Iterable` 接口（等同于聚合接口），可以通过 `iterator()` 方法获取一个 `Iterator` 对象来遍历集合。`for-each` 循环的底层实现就是基于迭代器模式。\n\n  ```java\n  List<String> list = new ArrayList<>();\n  // ... add elements\n  \n  // 显式使用迭代器\n  Iterator<String> it = list.iterator();\n  while(it.hasNext()) {\n      String s = it.next();\n      System.out.println(s);\n  }\n  \n  // for-each 循环（语法糖）\n  for (String s : list) {\n      System.out.println(s);\n  }\n  ```"
  },
  {
    "name": "状态模式",
    "summary": "允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。",
    "notes": "# 状态模式\n\n## 解决的问题\n当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变其行为时，如果使用大量的 `if-else` 或 `switch-case` 语句来判断状态，会导致代码臃肿、难以维护。状态模式通过将与特定状态相关的行为局部化，并将不同状态的行为分布在不同的状态类中，从而解决了这个问题。\n\n## 核心思想与实现方式\n1.  **定义一个状态接口 (State)**：该接口定义了所有具体状态类必须实现的行为方法。\n2.  **创建多个具体状态类 (Concrete State)**：每个类实现状态接口，封装了与特定状态相关的行为。每个状态类还负责在适当的时机将上下文对象的状态切换到下一个状态。\n3.  **创建一个上下文类 (Context)**：该类持有一个状态接口的引用，代表当前状态。上下文类将所有与状态相关的行为委托给当前的状态对象来处理。它通常也提供一个方法来改变当前状态。\n\n## UML 类图\n- **Context**: 定义客户端感兴趣的接口，并维护一个 `ConcreteState` 子类的实例，这个实例定义当前状态。\n- **State**: 定义一个接口以封装与 `Context` 的一个特定状态相关的行为。\n- **ConcreteStateA / ConcreteStateB**: 每一个子类实现一个与 `Context` 的一个状态相关的行为。\n\n## 优缺点\n- **优点**：\n  - **封装性**：将与特定状态相关的行为封装在对应的状态类中，使得代码结构更清晰。\n  - **消除条件语句**：避免了冗长的 `if-else`，易于维护。\n  - **易于扩展**：增加新的状态和转换非常方便，只需增加新的状态类即可，符合开闭原则。\n- **缺点**：\n  - 会导致系统中类的数量增加。\n  - 状态模式的结构与实现都较为复杂，如果状态不多，使用 `if-else` 可能更直观。\n\n## 使用场景\n- 一个对象的行为依赖于它的状态，并且可以根据状态的改变而改变。\n- 代码中包含大量与对象状态有关的条件语句。\n- 需要实现状态机模型的场景，如工作流、订单状态流转等。\n\n## 注意事项与常见问题\n- **与策略模式的区别**：\n  - **目的**：状态模式关注的是对象在不同状态下的行为变化和状态转换；策略模式关注的是封装和替换不同的算法。\n  - **状态感知**：状态模式的各个状态类之间是相互知晓的，并负责状态的切换；策略模式的各个策略类之间是相互独立的，不知道彼此的存在。\n  - **行为改变者**：状态模式的行为改变是对象内部状态驱动的（自发）；策略模式的行为改变是由外部客户端选择的（被动）。\n\n## 在 Spring/Java 中的应用\n- **工作流引擎**：在复杂的业务流程中，一个工单（如请假申请）有多种状态（待审批、已批准、已驳回等），在不同状态下，允许的操作（如“批准”、“撤销”）是不同的。使用状态模式可以清晰地管理这些状态和行为。\n- **游戏开发**：游戏角色的状态（如站立、行走、攻击、防御）会影响其行为，可以使用状态模式来管理。\n- **TCP 连接状态**：TCP 协议的状态机（如 `CLOSED`, `LISTEN`, `ESTABLISHED`）也是状态模式的一个典型例子。"
  },
  {
    "name": "访问者模式",
    "summary": "表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。",
    "notes": "# 访问者模式\n\n## 解决的问题\n当一个数据结构（如对象树）包含多种类型的对象，并且需要对这些对象执行多种不同的、将来可能需要扩展的操作时，如果将这些操作都定义在对象类中，会导致对象类变得臃肿且难以维护。访问者模式将数据结构和作用于其上的操作解耦，使得增加新的操作变得简单。\n\n## 核心思想与实现方式\n1.  **访问者接口 (Visitor)**：为数据结构中的每一种具体元素（`ConcreteElement`）声明一个 `visit` 方法，如 `visit(ConcreteElementA elementA)`，`visit(ConcreteElementB elementB)`。\n2.  **具体访问者类 (Concrete Visitor)**：实现访问者接口，为每种元素提供具体的操作实现。\n3.  **元素接口 (Element)**：定义一个 `accept` 方法，该方法接受一个 `Visitor` 对象作为参数。\n4.  **具体元素类 (Concrete Element)**：实现元素接口。其 `accept` 方法的实现通常是 `visitor.visit(this)`，将自身传递给访问者。\n5.  **对象结构 (Object Structure)**：一个能枚举其所有元素的集合，通常提供一个方法来接受访问者，并遍历所有元素调用其 `accept` 方法。\n\n这个过程利用了两次方法分派（Double Dispatch）：第一次是调用元素的 `accept(visitor)` 方法，第二次是在 `accept` 方法内部调用 `visitor.visit(this)`。这使得最终执行的操作同时取决于元素的具体类型和访问者的具体类型。\n\n## UML 类图\n- **Visitor**: 为 `ObjectStructure` 中的每个 `ConcreteElement` 声明一个 `Visit` 操作。\n- **ConcreteVisitor**: 实现 `Visitor` 声明的每个操作。\n- **Element**: 定义一个 `Accept` 操作，它以一个 `Visitor` 作为参数。\n- **ConcreteElement**: 实现 `Accept` 操作。\n- **ObjectStructure**: 能枚举它的元素，可以提供一个高层的接口以允许 `Visitor` 访问它的元素。\n\n## 优缺点\n- **优点**：\n  - **易于增加新操作**：增加一个新的操作只需增加一个新的具体访问者类，符合开闭原则。\n  - **数据与行为分离**：将数据结构和作用于其上的操作分离，使得类的职责更单一。\n  - **集中管理**：可以将相关的操作集中在一个访问者类中，而不是分散在各个元素类里。\n- **缺点**：\n  - **难以增加新元素**：每当在数据结构中增加一个新的具体元素类时，都需要修改所有访问者接口和所有具体访问者类，违反了开闭原则。\n  - **破坏封装**：访问者为了执行操作，可能需要访问元素的内部状态，这可能需要元素类暴露更多的 `public` 方法。\n\n## 使用场景\n- 对象结构中包含多种类型的对象，并且希望对这些对象实施一些依赖于其具体类型的操作。\n- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你希望避免让这些操作“污染”这些对象的类。\n- 对象结构相对稳定，但经常需要定义新的操作。\n\n## 在 Spring/Java 中的应用\n- **编译器**：编译器在处理抽象语法树（AST）时，经常使用访问者模式。AST 由不同类型的节点（如变量声明、赋值语句、循环语句）组成，而编译器需要对其进行多种操作（如类型检查、代码优化、代码生成）。每种操作都可以实现为一个访问者。\n- **`java.nio.file.FileVisitor`**：Java NIO 中的文件树遍历API。`Files.walkFileTree(path, visitor)` 方法接受一个 `FileVisitor` 实例，当遍历文件树时，会根据是文件还是目录，以及是在进入目录前还是后，调用 `FileVisitor` 的不同方法（`visitFile`, `preVisitDirectory` 等）。\n- **Spring Expression Language (SpEL)**：SpEL 的解析器可能会使用访问者模式来遍历和评估表达式树。"
  },
  {
    "name": "备忘录模式",
    "summary": "在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。",
    "notes": "# 备忘录模式\n\n## 解决的问题\n在某些场景下，需要记录一个对象的某个时刻的状态，以便后续可以恢复到这个状态，但又不希望为了保存状态而暴露对象的内部实现细节（即破坏封装性）。备忘录模式通过引入一个专门的“备忘录”对象来解决这个问题。\n\n## 核心思想与实现方式\n该模式包含三个核心角色：\n1.  **发起人 (Originator)**：这是需要被保存状态的对象。它负责创建一个包含其当前内部状态的备忘录对象，并且可以使用备忘录对象来恢复其内部状态。发起人知道如何与备忘录交互，但备忘录对发起人来说是透明的。\n2.  **备忘录 (Memento)**：这个对象负责存储发起人对象的内部状态。为了保护封装性，备忘录应该防止除发起人以外的任何其他对象访问其内部。通常，它对发起人是“宽接口”，对其他对象是“窄接口”。\n3.  **负责人 (Caretaker)**：也叫管理者，它负责保存备忘录对象，但它不应该检查或修改备忘录的内容。负责人只知道如何存储和提供备忘录，对备忘录的内容是无知的。它像一个仓库管理员。\n\n## UML 类图\n- **Originator**: 创建一个 `Memento`，用于记录当前时刻它的内部状态，并可使用 `Memento` 恢复内部状态。\n- **Memento**: 负责存储 `Originator` 对象的内部状态，并可防止 `Originator` 以外的其他对象访问 `Memento`。\n- **Caretaker**: 负责保存好 `Memento`，不能对 `Memento` 的内容进行操作或检查。\n\n## 优缺点\n- **优点**：\n  - **封装性**：保持了发起人内部状态的封装，因为只有发起人自己才能访问备忘录的内部数据。\n  - **简化发起人**：发起人不需要关心状态的存储和管理，这些职责被转移到了负责人身上。\n  - **状态恢复**：提供了一种简单的机制来实现状态的保存和恢复。\n- **缺点**：\n  - **资源消耗**：如果发起人的状态非常复杂或频繁地创建备忘录，可能会消耗大量的内存。\n\n## 使用场景\n- 需要保存和恢复数据的场景，如文本编辑器的撤销/重做功能。\n- 需要实现“快照”功能的场景，如游戏存档、虚拟机快照。\n- 数据库事务中的回滚操作。\n\n## 注意事项与常见问题\n- **实现封装性**：在 Java 中，可以通过将 `Memento` 定义为 `Originator` 的内部类，并将其状态字段设为 `private` 来实现封装。这样，只有 `Originator` 才能访问 `Memento` 的私有成员，而 `Caretaker` 只能持有 `Memento` 的引用。\n\n## 在 Spring/Java 中的应用\n- **`java.io.Serializable`**：虽然不是严格的备忘录模式，但序列化机制在思想上是相似的。它将一个对象的状态（其成员变量）捕获并写入到一个字节流中，之后可以从这个流中恢复对象的状态。这个字节流就扮演了备忘ror的角色。\n- **Web 流程中的状态保存**：在一些多步骤的 Web 表单向导中，用户每完成一步，可以将当前表单的状态序列化并存储在会话（Session）中。如果用户想返回上一步，可以从会话中恢复之前的状态。这里的会话扮演了负责人的角色。\n- **Spring Web Flow**：Spring Web Flow 框架用于管理跨越多个HTTP请求的会话状态，其内部就使用了类似备忘录的机制来保存和恢复流程状态。"
  },
  {
    "name": "中介者模式",
    "summary": "用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。",
    "notes": "# 中介者模式\n\n## 解决的问题\n当系统中对象之间存在复杂的网状交互关系时，每个对象都需要维护对其他多个对象的引用，导致系统耦合度极高，难以理解和维护。中介者模式通过引入一个中心化的中介者对象，将这种网状结构转变为星型结构，从而解决了这个问题。\n\n## 核心思想与实现方式\n1.  **定义中介者接口 (Mediator)**：定义了同事对象（`Colleague`）与中介者通信的接口。\n2.  **定义同事接口/抽象类 (Colleague)**：每个同事对象都知道其中介者对象，并持有一个对中介者的引用。它只与中介者通信，而不与其他同事直接通信。\n3.  **创建具体中介者类 (Concrete Mediator)**：实现中介者接口。它了解并维护所有的具体同事对象，并负责协调它们之间的交互。当某个同事对象发生变化时，它会通知中介者，由中介者决定如何影响其他同事。\n4.  **创建具体同事类 (Concrete Colleague)**：实现同事接口。当需要与其他同事交互时，它会通知中介者，由中介者来完成转发和协调。\n\n## UML 类图\n- **Mediator**: 定义一个接口用于与各 `Colleague` 对象通信。\n- **ConcreteMediator**: 实现 `Mediator` 接口，协调各 `Colleague` 对象间的合作关系。\n- **Colleague**: 定义每个同事类都知道其中介者对象。\n- **ConcreteColleague**: 每个同事类都只知道其中介者，即它的所有交互都通过中介者。\n\n## 优缺点\n- **优点**：\n  - **降低耦合**：将多对多的复杂关系简化为一对多的关系，极大地降低了同事对象之间的耦合。\n  - **集中控制**：将复杂的交互逻辑集中在中介者中，便于管理和维护。\n  - **增强复用性**：同事类因为解耦而变得更加通用和可复用。\n- **缺点**：\n  - **中介者膨胀**：随着系统中同事对象的增多，中介者的逻辑会变得异常复杂，可能演变成一个难以维护的“上帝类” (God Class)。\n\n## 使用场景\n- 一组对象以定义良好但复杂的方式进行通信，导致相互依赖关系混乱且难以理解。\n- 一个对象引用了其他很多对象并且与它们交互，导致该对象难以复用。\n- 想要自定义一个分布在多个类中的行为，而又不想生成太多的子类。\n\n## 注意事项与常见问题\n- **中介者模式的滥用**：如果对象间的交互逻辑非常简单，引入中介者模式反而会增加不必要的复杂性。它适用于交互关系确实已经变得混乱的场景。\n\n## 在 Spring/Java 中的应用\n- **`java.util.Timer`**：`Timer` 类可以被看作是一个中介者。它可以调度多个 `TimerTask`（同事对象）在指定时间执行。`TimerTask` 之间互不关心，它们的调度完全由 `Timer` 来协调。\n- **MVC (Model-View-Controller) 模式**：在经典的 MVC 架构中，`Controller` 扮演了 `View` 和 `Model` 之间的中介者。`View` 上的用户操作会通知 `Controller`，`Controller` 更新 `Model`；`Model` 的数据变化也可能通过 `Controller` (或观察者模式) 来更新 `View`。`View` 和 `Model` 之间不直接通信。\n- **Spring框架**：Spring 的 `ApplicationContext` 在某种程度上也扮演了中介者的角色。它管理着所有的 Bean（同事），并负责处理它们之间的依赖关系（通过依赖注入）。Bean 之间不需要自己去查找和管理依赖，而是由容器统一协调。"
  },
  {
    "name": "解释器模式",
    "summary": "给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。",
    "notes": "# 解释器模式\n\n## 解决的问题\n当有一个特定领域的问题，其解决方案可以被形式化为一种简单的语言或文法时，解释器模式提供了一种构建解释器来处理这种语言的框架。它使得我们可以轻松地为这门“迷你语言”添加新的表达式和规则。\n\n## 核心思想与实现方式\n解释器模式通常用于构建一个简单的语法树（AST, Abstract Syntax Tree）来表示语言中的句子。\n1.  **定义抽象表达式接口 (Abstract Expression)**：通常包含一个 `interpret()` 方法，该方法接受一个上下文（`Context`）对象作为参数，该上下文包含了需要被解释的全局信息。\n2.  **创建终结符表达式类 (Terminal Expression)**：表示文法中的终结符（即最基本的元素，不能再被分解）。它实现了抽象表达式接口。\n3.  **创建非终结符表达式类 (Non-terminal Expression)**：表示文法中的非终结符（即由其他表达式组成的复杂规则）。它通常包含对其他抽象表达式的引用，其 `interpret()` 方法会递归地调用这些引用的 `interpret()` 方法。\n4.  **创建上下文类 (Context)**：包含解释器之外的一些全局信息。\n5.  **客户端 (Client)**：客户端负责构建代表特定句子的语法树，并调用其顶层节点的 `interpret()` 方法开始解释过程。\n\n## UML 类图\n- **AbstractExpression**: 声明一个 `Interpret` 操作，所有 `TerminalExpression` 和 `NonterminalExpression` 节点都实现此接口。\n- **TerminalExpression**: 实现与文法中的终结符相关联的 `Interpret` 操作。\n- **NonterminalExpression**: 对文法中的每一条规则 `R ::= R1 R2 ... Rn` 都需要一个 `NonterminalExpression` 类。为 `R1` 到 `Rn` 的每个符号都维护一个实例变量。\n- **Context**: 包含解释器之外的一些全局信息。\n- **Client**: 构建(或被给定)一个表示文法中一个特定句子的抽象语法树。\n\n## 优缺点\n- **优点**：\n  - **易于扩展**：修改和扩展文法非常方便，因为可以通过增加新的终结符或非终结符表达式类来实现，符合开闭原则。\n  - **灵活性高**：由于文法由类表示，可以轻松地改变或扩展语言。\n- **缺点**：\n  - **性能问题**：对于复杂的文法，可能会产生大量的类，并且解析过程可能涉及深度递归，导致效率低下。\n  - **维护复杂**：当文法规则非常多时，维护大量的表达式类会变得很困难。\n\n## 使用场景\n- 当一个特定类型的问题发生的频率足够高，以至于值得将该问题的各个实例表述为一个简单语言中的句子。\n- 可以将一个问题表示为一枚语言时，可使用解释器模式。\n- **不适用场景**：对于复杂的文法，通常会使用专门的解析器生成工具（如 ANTLR, JavaCC）来代替手动实现解释器模式。\n\n## 在 Spring/Java 中的应用\n- **`java.util.regex.Pattern`**：Java 的正则表达式引擎就是解释器模式的一个复杂应用。正则表达式本身就是一门迷你语言，`Pattern` 类负责将正则表达式字符串编译成一个内部的、可执行的表示（类似语法树），然后用它来匹配输入字符串。\n- **Spring Expression Language (SpEL)**：SpEL 允许在运行时查询和操作对象图。表达式如 `#{'Hello World'.bytes.length}` 会被解析成一个表达式树，然后通过解释器来求值。SpEL 的实现深度使用了该模式。\n- **SQL 解析**：数据库系统在执行 SQL 查询时，首先需要一个 SQL 解析器将 SQL 字符串解析成一棵语法树，然后再进行优化和执行。这个解析过程就是解释器模式的应用。"
  },
    {
      "name": "依赖注入/ 控制反转",
      "summary": "将组件获取其依赖关系的控制权从组件自身转移到外部容器，从而实现解耦和可测试性，是现代框架的基石。",
      "notes": "# 依赖注入 (DI) / 控制反转 (IoC)\n\n## 解决的问题\n\n解决了组件之间高度耦合的问题。在传统模式下，一个组件需要自己创建或查找它所依赖的其他对象（`new dependency()`），这导致组件之间紧密绑定，使得代码难以测试、复用和替换。\n\n## 核心思想与实现方式\n\n- **控制反转 (Inversion of Control, IoC)**：这是一个宏观的设计原则。传统程序是应用代码主动控制执行流程和对象的创建，而 IoC 则是将这个控制权“反转”给了外部的框架或容器。应用代码不再主动创建依赖，而是被动地等待容器提供。\n\n- **依赖注入 (Dependency Injection, DI)**：这是 IoC 最常见和最重要的一种实现方式。容器在运行时，主动将被依赖的对象（即“依赖”）“注入”到需要它的组件中。开发者只需在组件中声明其依赖即可。\n\n### 主要实现方式\n\n1.  **构造函数注入 (Constructor Injection)**：通过类的构造函数传递依赖。这是最推荐的方式，因为它可以保证依赖在对象创建时就已完备，且易于创建不可变对象。\n\n    ```java\n    private final DependencyA depA;\n\n    @Autowired\n    public MyComponent(DependencyA depA) {\n        this.depA = depA;\n    }\n    ```\n\n2.  **Setter 注入 (Setter Injection)**：通过 setter 方法注入依赖。这种方式更灵活，允许依赖的可选性和动态变更，但可能导致对象在某些时刻处于不完整状态。\n\n    ```java\n    private DependencyB depB;\n\n    @Autowired\n    public void setDepB(DependencyB depB) {\n        this.depB = depB;\n    }\n    ```\n\n3.  **字段注入 (Field Injection)**：直接在字段上使用注解（如 `@Autowired`）注入。代码最简洁，但与容器耦合最紧密，不便于单元测试，因此**不推荐**在业务代码中使用。\n\n    ```java\n    @Autowired\n    private DependencyC depC;\n    ```\n\n## 优缺点\n\n- **优点**：\n  - **解耦**：极大降低了组件间的耦合度。\n  - **可测试性**：非常容易通过模拟（Mock）依赖来进行单元测试。\n  - **可复用和可维护性**：组件职责更单一，易于复用和维护。\n\n- **缺点**：\n  - **学习成本**：需要理解框架和容器的工作原理。\n  - **配置复杂**：在大型项目中，依赖关系的管理可能变得复杂。\n  - **可追溯性**：依赖关系在代码中不那么直观，需要借助工具或框架来理解。\n\n## 使用场景\n\n几乎所有现代企业级应用框架的核心，如 Spring、Guice、Dagger 等。任何需要构建模块化、可测试、可扩展的系统时都应使用。\n\n## 注意事项\n\n- **循环依赖**：要警惕A依赖B，B又依赖A的循环依赖问题。构造函数注入可以有效发现此问题，而 Setter 注入可能会掩盖它。\n- **优先使用构造函数注入**：这是最佳实践，能保证依赖的明确性和不变性。\n\n## 在 Spring/Java 中的应用\n\n- **Spring IoC 容器**：是 DI 模式最著名和最强大的实现。通过 `ApplicationContext` 管理 Bean 的生命周期和依赖关系。\n- **`@Autowired`**, **`@Resource`**, **`@Inject`**：这些注解都是在 Spring 中实现依赖注入的工具。"
    },
    {
      "name": "空对象模式",
      "summary": "使用一个行为中立、无操作的空对象来代替 `null`，从而避免繁琐的空指针检查，使代码更简洁健壮。",
      "notes": "# 空对象模式 (Null Object Pattern)\n\n## 解决的问题\n\n解决了代码中充斥大量 `if (object != null)` 检查的问题。这些检查不仅使代码变得臃肿、可读性差，而且容易因遗漏检查而导致 `NullPointerException`，这是 Java 中最常见的运行时异常之一。\n\n## 核心思想与实现方式\n\n核心思想是创建一个与真实业务对象实现相同接口的“空对象”。这个空对象的所有方法都是空实现（即什么也不做）或者返回一个无害的默认值（如 0、空字符串、空集合）。\n\n当逻辑上一个对象可能不存在时，方法不返回 `null`，而是返回这个预先定义好的空对象。这样，客户端代码就可以像对待普通对象一样调用其方法，而无需进行 `null` 检查。\n\n```java\n// 抽象接口\ninterface User {\n    String getName();\n    boolean hasAccess();\n}\n\n// 真实对象\nclass RealUser implements User {\n    // ... 实现\n}\n\n// 空对象\nclass NullUser implements User {\n    @Override\n    public String getName() { return \"Guest\"; }\n    @Override\n    public boolean hasAccess() { return false; }\n}\n\n// 工厂方法\nclass UserFactory {\n    public static User getUser(String id) {\n        if (/* user exists */) {\n            return new RealUser(/* ... */);\n        }\n        return new NullUser(); // 返回空对象而不是 null\n    }\n}\n```\n\n## 优缺点\n\n- **优点**：\n  - **简化客户端代码**：消除了对 `null` 的判断，使代码更流畅。\n  - **提高健壮性**：从根本上减少了 `NullPointerException` 的可能性。\n  - **代码可读性**：意图更清晰，调用者无需关心返回值是否为 `null`。\n\n- **缺点**：\n  - **类数量增加**：需要为可能为 `null` 的对象创建对应的空对象类。\n  - **可能掩盖问题**：如果空对象的“无害”行为不符合预期，可能会掩盖本应被发现的错误。\n\n## 使用场景\n\n- 当一个方法返回的对象，其调用方在多数情况下不需要区分“无”和“有”的细微差别时。\n- 当希望为“不存在”的情况提供一个默认的、无害的行为时。\n- 策略模式中，可以提供一个空策略作为默认选项。\n\n## 注意事项\n\n- 此模式并不适合所有场景。如果 `null` 本身是一种重要的业务信号（例如，“未找到记录”和“找到记录但其值为 `null`”需要区分处理），则不应使用空对象模式。\n- **与 `Optional` 的比较**：Java 8 引入的 `Optional` 提供了另一种解决 `null` 问题的方案。`Optional` 强迫调用者显式处理“可能为空”的情况，而空对象模式则是隐式处理。两者各有优劣，应根据具体场景选择。\n\n## 在 Spring/Java 中的应用\n\n- `java.util.Collections.emptyList()`、`emptyMap()`、`emptySet()` 是空对象模式的经典体现。它们返回一个不可变的空集合，可以安全地对其进行迭代等操作，而无需 `null` 检查。"
    },
    {
      "name": "事件总线模式",
      "summary": "提供一个中央事件通道，允许不同组件之间进行发布-订阅式通信，而无需直接相互依赖，实现彻底解耦。",
      "notes": "# 事件总线模式 (Event Bus Pattern)\n\n## 解决的问题\n\n解决了传统观察者模式中，观察者（Subscriber）和被观察者（Publisher）之间仍然存在的直接耦合问题。在复杂系统中，如果组件间都使用直接的事件监听，会导致网状的依赖关系，难以管理和维护。事件总线模式旨在实现组件间的终极解耦。\n\n## 核心思想与实现方式\n\n引入一个全局的、单例的“总线”（Event Bus）对象。整个通信流程如下：\n\n1.  **订阅者 (Subscriber)**：对某个特定类型的事件感兴趣的组件，向事件总线注册（订阅）自己，并提供一个处理该事件的方法。\n2.  **发布者 (Publisher)**：当某个事件发生时，发布者不直接通知任何订阅者，而是将事件发布到事件总线上。\n3.  **事件总线 (Event Bus)**：接收到事件后，查找所有订阅了该类型事件的订阅者，并将事件分发给它们。\n\n通过这种方式，发布者和订阅者之间完全不知道对方的存在，它们只与事件总线交互。\n\n## 优缺点\n\n- **优点**：\n  - **彻底解耦**：组件间通信的耦合度降到最低。\n  - **简化通信**：代码逻辑清晰，发布者只需发送事件，订阅者只需处理事件。\n  - **灵活性**：可以非常方便地在运行时动态添加或移除事件监听器。\n\n- **缺点**：\n  - **可追溯性差**：事件的流向不直观，因为发布者和订阅者是解耦的，调试时难以追踪事件的来源和去向。\n  - **可能影响性能**：如果总线实现不佳或事件过多，可能成为性能瓶颈。\n  - **易于滥用**：过度使用可能导致系统逻辑变得混乱和难以理解。\n\n## 使用场景\n\n- GUI 应用程序中不同 UI 组件间的通信。\n- 大型单体应用中不同模块间的解耦。\n- 微服务架构中，作为服务内部不同组件进行异步通信的机制。\n- 需要实现“发布-订阅”模型的任何场景。\n\n## 注意事项\n\n- **线程模型**：需要明确事件总线的线程模型。事件是同步分发（发布者线程阻塞直到所有订阅者处理完毕）还是异步分发（使用线程池在后台处理）？\n- **错误处理**：需要考虑当订阅者处理事件抛出异常时，事件总线应如何处理（例如，是否影响其他订阅者）。\n- **避免循环事件**：警惕订阅者在处理事件A时又发布了事件B，而事件B的某个订阅者又发布了事件A，导致死循环。\n\n## 在 Spring/Java 中的应用\n\n- **Spring ApplicationEvent 机制**：Spring 框架内置的事件机制就是一种事件总线的实现。通过 `ApplicationEventPublisher` 发布事件，通过 `@EventListener` 注解或实现 `ApplicationListener` 接口来订阅事件。\n- **Google Guava 的 `EventBus`**：一个非常著名且易于使用的事件总线库。\n- **Axon Framework**：在 CQRS 和事件溯源领域，`EventBus` 是其核心组件之一。"
    },
    {
      "name": "生产者-消费者模式",
      "summary": "通过一个共享的缓冲区来解耦生产者（任务创建者）和消费者（任务执行者），从而平衡两者间的处理速度差异。",
      "notes": "# 生产者-消费者模式 (Producer-Consumer Pattern)\n\n## 解决的问题\n\n这是一种经典的多线程协作模式，主要解决以下问题：\n\n- **速度不匹配**：生产者生产数据的速度与消费者消费数据的速度不一致。此模式通过一个共享的缓冲区作为中介，可以有效地“削峰填谷”。\n- **解耦**：生产者和消费者之间不直接通信，只与共享缓冲区交互，降低了耦合度。\n- **异步处理**：允许生产者在提交任务后立即返回，而无需等待任务被处理完成，提高了系统的响应能力。\n\n## 核心思想与实现方式\n\n该模式包含三个核心角色：\n\n1.  **生产者 (Producer)**：负责创建数据或任务，并将其放入一个共享的缓冲区。如果缓冲区已满，生产者需要等待。\n2.  **消费者 (Consumer)**：从缓冲区中取出数据或任务进行处理。如果缓冲区为空，消费者需要等待。\n3.  **缓冲区 (Buffer/Queue)**：一个共享的、线程安全的数据结构（通常是一个有界队列），用于存储生产者放入、消费者取出的数据。它负责协调生产者和消费者的步调。\n\n在 Java 中，通常使用 `java.util.concurrent.BlockingQueue`（阻塞队列）来实现缓冲区，它内置了线程同步和等待/唤醒机制。\n\n```java\nBlockingQueue<Task> queue = new ArrayBlockingQueue<>(10);\n\n// 生产者线程\nnew Thread(() -> {\n    while(true) {\n        Task task = produceTask();\n        queue.put(task); // 如果队列满，会自动阻塞\n    }\n}).start();\n\n// 消费者线程\nnew Thread(() -> {\n    while(true) {\n        Task task = queue.take(); // 如果队列空，会自动阻塞\n        processTask(task);\n    }\n}).start();\n```\n\n## 优缺点\n\n- **优点**：\n  - **解耦**：生产者和消费者职责单一，相互独立。\n  - **提高吞吐量**：生产者和消费者可以并行工作，有效利用多核 CPU 资源。\n  - **流量整形**：能够平滑处理突发性的高并发请求，起到缓冲和削峰的作用。\n\n- **缺点**：\n  - **实现复杂性**：需要处理好多线程同步、死锁等问题（尽管 `BlockingQueue` 已大大简化）。\n  - **缓冲区瓶颈**：如果缓冲区大小设置不当，可能成为系统瓶颈。\n\n## 使用场景\n\n- **日志系统**：应用线程（生产者）产生日志，专门的写日志线程（消费者）将其写入文件。\n- **Web 服务器**：请求接收线程（生产者）将请求放入队列，工作线程（消费者）从队列中取出并处理。\n- **消息队列系统**：如 RabbitMQ、Kafka 等，是该模式在分布式环境中的宏观体现。\n- 任何需要将耗时操作异步化的场景。\n\n## 在 Spring/Java 中的应用\n\n- **`java.util.concurrent.BlockingQueue`** 接口及其实现类（如 `ArrayBlockingQueue`, `LinkedBlockingQueue`）是实现此模式的基石。\n- **`ThreadPoolExecutor`** 的工作原理就是生产者-消费者模式的变体：任务提交者是生产者，线程池中的工作线程是消费者，任务队列是缓冲区。\n- Spring 的 `@Async` 注解执行异步任务时，底层也是依赖于线程池和任务队列。"
    },
    {
      "name": "线程池模式",
      "summary": "预先创建并管理一组线程，任务到达时从池中获取线程执行，从而避免频繁创建和销毁线程带来的性能开销。",
      "notes": "# 线程池模式 (Thread Pool Pattern)\n\n## 解决的问题\n\n在并发编程中，如果为每个任务都创建一个新线程，会带来以下问题：\n\n1.  **高昂的资源开销**：线程的创建和销毁是需要消耗系统资源的，频繁操作会严重影响性能。\n2.  **无限制创建的风险**：如果不加限制地创建线程，可能会耗尽系统内存和 CPU 资源，导致系统崩溃。\n3.  **缺乏统一管理**：大量分散的线程难以监控、管理和调优。\n\n线程池模式通过复用已创建的线程，有效地解决了这些问题。\n\n## 核心思想与实现方式\n\n核心思想是“池化”技术，即预先创建一定数量的线程放入一个“池”中进行统一管理。当有任务需要执行时：\n\n1.  从池中请求一个空闲线程。\n2.  如果池中有空闲线程，则分配该线程执行任务。\n3.  如果池中没有空闲线程，根据配置的策略进行处理（例如，放入任务队列等待、创建新线程、或拒绝任务）。\n4.  任务执行完毕后，线程不会被销毁，而是返回池中，等待下一个任务。\n\nJava 的 `java.util.concurrent.ThreadPoolExecutor` 是线程池的核心实现，它有几个关键参数：\n\n- `corePoolSize`：核心线程数，池中始终保持的最小线程数。\n- `maximumPoolSize`：最大线程数，池中允许存在的最大线程数。\n- `keepAliveTime`：当线程数超过核心数时，空闲线程的存活时间。\n- `workQueue`：任务队列，用于存放等待执行的任务。\n- `handler`：拒绝策略，当队列已满且线程数达到最大时，如何处理新任务。\n\n## 优缺点\n\n- **优点**：\n  - **降低资源消耗**：通过复用线程，减少了创建和销毁的开销。\n  - **提高响应速度**：任务无需等待线程创建即可立即执行。\n  - **提高可管理性**：便于统一分配、调优和监控线程。\n  - **提供资源限制**：可以控制并发线程数量，防止资源耗尽。\n\n- **缺点**：\n  - **配置复杂**：线程池参数的配置需要根据具体业务场景进行仔细调优，否则可能达不到预期效果甚至降低性能。\n  - **可能导致死锁**：如果任务之间存在依赖，且线程池大小不足，可能引发死锁。\n\n## 使用场景\n\n- 需要处理大量并发、耗时较短的任务的场景。\n- Web 服务器、数据库连接池、消息中间件等高性能服务中必不可少。\n- 任何需要执行异步任务的后台服务。\n\n## 注意事项\n\n- **禁止使用 `Executors` 的快捷创建方法**：`Executors.newFixedThreadPool()`、`newSingleThreadExecutor()` 和 `newCachedThreadPool()` 创建的线程池都存在潜在的资源耗尽风险（如无界队列），在《阿里巴巴Java开发手册》中被列为禁止项。推荐直接使用 `ThreadPoolExecutor` 构造函数手动创建，以明确控制所有参数。\n- **合理配置参数**：需要根据任务是 CPU 密集型还是 I/O 密集型来估算合理的线程数。\n\n## 在 Spring/Java 中的应用\n\n- **`java.util.concurrent.ExecutorService`** 和 **`ThreadPoolExecutor`** 是 Java 并发包中线程池的标准实现。\n- Spring 的 **`@Async`** 注解默认使用一个可配置的 `TaskExecutor`（通常是 `ThreadPoolTaskExecutor`）来执行异步方法。\n- 许多框架，如 Netty、Tomcat，内部都广泛使用了线程池来处理网络请求和I/O操作。"
    },
    {
      "name": "服务注册与发现",
      "summary": "在分布式系统中，自动维护服务实例的网络地址列表，使服务间能动态地找到对方并进行通信。",
      "notes": "# 服务注册与发现\n\n## 解决的问题\n\n在微服务架构中，服务实例的网络位置（IP地址、端口）是动态变化的，尤其是在使用容器化和弹性伸缩时。硬编码服务地址是不可行的。服务发现模式解决了服务实例如何动态地找到彼此的问题。\n\n## 核心思想与实现方式\n\n1.  **服务注册**：每个服务实例在启动时，将自己的网络地址等元数据注册到一个中心化的“服务注册中心”。\n2.  **服务发现**：当一个服务（客户端）需要调用另一个服务（提供者）时，它会向注册中心查询提供者的地址列表。\n3.  **健康检查**：服务实例会定期向注册中心发送心跳，以表明自己仍处于活动状态。如果注册中心在一段时间内未收到心跳，就会将该实例从可用列表中剔除。\n\n有两种主要实现方式：\n- **客户端发现**：客户端负责查询注册中心并进行负载均衡。\n- **服务端发现**：客户端将请求发送给一个负载均衡器（Router），由它来查询注册中心并路由请求。\n\n## 优缺点\n\n- **优点**：\n  - 实现服务间的解耦，无需关心具体IP和端口。\n  - 提高系统的弹性和可用性，能够自动适应实例的增减。\n- **缺点**：\n  - 引入了新的组件（服务注册中心），该组件必须是高可用的，否则会成为系统的单点故障。\n\n## 常用工具与框架\n\n- **Spring Cloud Netflix Eureka**: 客户端发现模式的经典实现。\n- **HashiCorp Consul**: 提供服务发现、健康检查和K/V存储。\n- **Alibaba Nacos**: 集服务发现和配置管理于一体。\n- **Kubernetes**: 原生提供基于DNS和Service资源的服务发现机制，是当前云原生环境下的主流方案。\n\n## 注意事项\n\n- 健康检查机制至关重要，它决定了系统对服务故障的响应速度。\n- 注册中心自身的可用性是整个架构的关键，生产环境通常需要集群部署。"
    },
    {
      "name": "API 网关",
      "summary": "为微服务集群提供一个统一的入口，负责请求路由、协议转换、身份验证、限流和监控等横切关注点。",
      "notes": "# API 网关\n\n## 解决的问题\n\n- **客户端复杂性**：如果让客户端（如Web前端、移动App）直接与数十个微服务通信，会非常复杂，且需要处理服务发现、多请求等问题。\n- **横切关注点重复**：身份认证、授权、日志记录、限流等功能需要在每个微服务中重复实现。\n- **安全暴露面**：直接将所有微服务暴露给外部网络会增加安全风险。\n\n## 核心思想与实现方式\n\nAPI 网关作为所有外部请求的唯一入口，扮演“前门”的角色。它接收外部请求，然后根据请求的路径、头部等信息，将其路由到内部的相应微服务。在此过程中，它可以执行一系列的“过滤器”逻辑：\n\n- **请求路由 (Routing)**：核心功能，将请求转发到后端服务。\n- **身份认证与授权 (Authentication & Authorization)**：集中处理安全验证。\n- **协议转换 (Protocol Translation)**：例如将外部的HTTP请求转换为内部的RPC调用。\n- **响应聚合 (Response Aggregation)**：将来自多个微服务的响应聚合成一个单一的响应返回给客户端。\n- **限流与熔断 (Rate Limiting & Circuit Breaking)**：保护后端服务不被流量冲垮。\n\n## 优缺点\n\n- **优点**：\n  - 简化客户端，减少客户端与后端的耦合。\n  - 集中处理横切关注点，避免代码重复。\n  - 提升安全性，隐藏内部服务架构。\n- **缺点**：\n  - 网关自身可能成为性能瓶颈和单点故障，必须保证其高可用和可扩展性。\n  - 增加了系统的一层复杂性和一次网络跳转。\n\n## 常用工具与框架\n\n- **Spring Cloud Gateway**: 基于响应式编程（WebFlux）的现代网关，性能优异。\n- **Netflix Zuul**: Spring Cloud早期使用的网关，有1.x（阻塞）和2.x（非阻塞）版本。\n- **Kong / Nginx Plus**: 高性能的开源/商业网关。\n- **Kubernetes Ingress Controller**: K8s中的一种资源，用于管理对集群服务的外部访问，可视为一种API网关实现。\n\n## 注意事项\n\n- 网关的设计应保持轻量，避免将过多的业务逻辑放入网关，以防其演变成一个新的“单体”。\n- 必须对网关进行充分的监控和告警。"
    },
    {
      "name": "断路器",
      "summary": "防止因一个服务的故障导致整个系统的级联失败，通过在服务调用失败时快速失败（熔断）并提供降级策略来提高系统弹性。",
      "notes": "# 断路器\n\n## 解决的问题\n\n在微服务架构中，一个服务通常会依赖其他多个服务。如果其中一个被依赖的服务响应缓慢或失败，调用方可能会因为等待响应而耗尽资源（如线程池），最终导致自身也无法服务，这种故障会像雪崩一样在系统中蔓延，即“级联失败”。\n\n## 核心思想与实现方式\n\n断路器模式模拟了电路中的断路器。它包装了对外部服务的调用，并维护三个状态：\n\n1.  **关闭 (Closed)**：正常状态，允许所有请求通过。断路器会记录近期的失败次数。\n2.  **打开 (Open)**：当失败次数达到预设阈值时，断路器“跳闸”，进入打开状态。在此状态下，所有后续请求都会立即失败（快速失败），而不会去调用下游服务。这可以防止对已经出问题的服务造成更大压力。\n3.  **半开 (Half-Open)**：在打开状态持续一段时间（冷却期）后，断路器进入半开状态。它会允许一个“探测”请求通过。如果该请求成功，则断路器切换回关闭状态；如果失败，则重新回到打开状态，并开始新一轮的冷却计时。\n\n通常会配合一个“降级方法”（Fallback Method），在断路器打开或调用失败时，返回一个默认值、缓存数据或提示信息，而不是直接报错。\n\n## 优缺点\n\n- **优点**：\n  - 阻止级联失败，保护整个系统的稳定性。\n  - 实现“快速失败”，避免线程阻塞和资源耗尽。\n  - 提供优雅降级，提升用户体验。\n- **缺点**：\n  - 增加了代码的复杂性。\n  - 断路器的阈值（如失败率、冷却时间）需要仔细调优，否则可能导致“误判”。\n\n## 常用工具与框架\n\n- **Resilience4j**: 轻量、模块化的容错库，是目前Spring Cloud推荐的断路器实现。\n- **Netflix Hystrix**: 曾经是事实标准，但目前已进入维护模式。\n- **Alibaba Sentinel**: 功能强大的流量控制、熔断降级库。\n- **Istio (Service Mesh)**: 可以在服务网格层面提供断路器功能，对应用透明。\n\n## 注意事项\n\n- 降级逻辑的设计非常重要，它决定了系统在故障时的表现。\n- 应对不同服务、不同接口设置独立的断路器策略。"
    },
    {
      "name": "配置中心",
      "summary": "将所有微服务的配置信息集中存储和管理，支持配置的动态更新，避免修改配置需要重新部署服务。",
      "notes": "# 配置中心\n\n## 解决的问题\n\n- **配置分散**：在微服务架构中，每个服务都有自己的配置文件。随着服务数量和环境（开发、测试、生产）的增多，管理这些分散的配置文件变得极其困难。\n- **更新繁琐**：当一个配置项需要修改时，必须手动修改所有相关服务的配置文件，并逐一重启服务，操作繁琐且风险高。\n- **安全风险**：数据库密码等敏感信息硬编码在代码或配置文件中，存在安全隐患。\n\n## 核心思想与实现方式\n\n引入一个中心化的配置服务器。所有微服务实例在启动时都从这个配置服务器拉取自己的配置信息。配置服务器的后端可以连接到一个版本控制系统（如 Git）、数据库或键值存储。\n\n- **集中管理**：所有配置都在一个地方管理，便于审计和版本控制。\n- **动态刷新**：配置中心支持在不重启服务的情况下，动态地将变更的配置推送给所有相关的服务实例。这通常需要与消息总线（如RabbitMQ, Kafka）配合使用。\n- **环境隔离**：可以轻松地为不同的环境（`profile`）和不同的应用（`application`）提供不同的配置。\n\n## 优缺点\n\n- **优点**：\n  - 实现配置和代码的分离。\n  - 简化配置管理，提高运维效率。\n  - 支持配置的动态更新，提升系统灵活性。\n  - 便于实现权限控制和安全管理。\n- **缺点**：\n  - 引入了新的组件（配置中心），该组件必须是高可用的。\n  - 配置的加载和刷新机制会增加系统的启动和运行复杂性。\n\n## 常用工具与框架\n\n- **Spring Cloud Config**: Spring Cloud原生解决方案，通常与Git结合使用。\n- **Alibaba Nacos**: 集成了配置管理和服务发现功能。\n- **Ctrip Apollo (阿波罗)**: 功能强大，支持丰富的管理界面和多环境管理。\n- **HashiCorp Consul**: 其K/V存储功能也可用作配置中心。\n- **Kubernetes ConfigMap / Secret**: K8s原生资源，用于管理非敏感和敏感配置，可与Spring Cloud Kubernetes集成实现动态刷新。\n\n## 注意事项\n\n- 敏感信息（如密码、密钥）应该使用配置中心的加密功能或专门的Secret管理工具（如Vault、K8s Secret）进行管理。\n- 配置的变更应有严格的审批和发布流程。"
    },
    {
      "name": "边车模式",
      "summary": "将应用的功能分解到独立的进程中，这些进程（边车）与主应用进程一同部署和管理，通常用于实现跨语言的横切关注点。",
      "notes": "# 边车模式\n\n## 解决的问题\n\n在多语言（Polyglot）微服务架构中，如何为所有服务提供统一的横切关注点功能，如日志收集、监控、网络代理、安全等，而无需在每种语言中都重复实现这些库？\n\n## 核心思想与实现方式\n\n边车模式通过将这些通用功能从主应用程序中剥离出来，放到一个独立的、可复用的进程（“边车”）中。在容器化环境（如Kubernetes）中，主应用容器和边车容器会被部署在同一个Pod里。这意味着：\n\n- **共享生命周期**：它们一同启动、一同停止。\n- **共享资源**：它们共享同一个网络命名空间（可以通过`localhost`通信）和存储卷。\n\n主应用程序通过`localhost`与边车进程通信，将网络请求、日志等委托给边车处理。例如，一个Envoy代理作为边车，可以拦截应用的所有出入流量，从而实现服务发现、负载均衡、断路器等功能，而主应用对此完全无感。\n\n## 优缺点\n\n- **优点**：\n  - **语言无关**：边车可以用任何语言编写，主应用也可以是任何语言，实现了功能的解耦。\n  - **降低应用复杂性**：主应用可以专注于核心业务逻辑。\n  - **隔离性**：边车的故障不会直接导致主应用进程崩溃。\n- **缺点**：\n  - **资源开销**：每个应用实例都需要一个额外的边车进程，增加了资源消耗。\n  - **延迟增加**：增加了应用与边车之间的一次本地网络通信，会带来微小的延迟。\n  - **运维复杂性**：需要管理和部署更多的容器。\n\n## 常用工具与框架\n\n- **服务网格 (Service Mesh)**：边车模式是服务网格的核心。**Istio** 和 **Linkerd** 都通过注入一个代理边车（如Envoy）到每个Pod中来实现其功能。\n- **日志收集**: 可以部署一个如 **Fluentd** 或 **Logstash** 的边车来收集应用的日志，并将其发送到集中的日志系统。\n- **安全**: 可以使用边车来处理TLS终止、身份验证等安全任务。\n\n## 注意事项\n\n- 边车模式最适合容器化部署环境，特别是Kubernetes，它提供了Pod这一原子部署单元来完美支持该模式。\n- 需要权衡其带来的好处与额外的资源和运维成本。"
    },
    {
      "name": "命令查询职责分离",
      "summary": "将系统的数据读操作（查询）和写操作（命令）的模型分离开来，允许对读写两端进行独立的优化。",
      "notes": "# 命令查询职责分离 (CQRS)\n\n## 解决的问题\n\n在复杂的业务系统中，用于数据更新（写）的模型和用于数据显示（读）的模型往往有截然不同的需求。将它们合二为一会导致：\n\n- **模型臃肿**：单个模型既要处理复杂的业务验证和更新逻辑，又要满足多样的查询和展示需求，变得非常复杂。\n- **性能瓶颈**：读操作和写操作的性能需求不同。例如，写操作可能需要强一致性，而读操作可以容忍轻微延迟但要求高吞吐量。单一模型难以同时优化。\n- **扩展困难**：无法对读、写负载进行独立扩展。\n\n## 核心思想与实现方式\n\nCQRS（Command Query Responsibility Segregation）的核心思想是：任何方法都应该要么是执行动作的“命令”（Command），要么是返回数据的“查询”（Query），但不应两者都是。\n\n- **命令 (Command) 端**：负责处理所有的数据修改请求（增、删、改）。命令模型关注业务逻辑、验证和数据一致性。它通常操作一个为写优化的数据库模型（如规范化的关系型数据库）。\n- **查询 (Query) 端**：负责处理所有的数据读取请求。查询模型直接服务于UI展示，通常是一个或多个为读优化的、反规范化的数据模型（如宽表、文档数据库、搜索引擎索引）。\n\n命令端在完成数据修改后，会通过某种机制（通常是异步的事件）来更新查询端的数据。这导致了读写模型之间的**最终一致性**。\n\n## 优缺点\n\n- **优点**：\n  - **独立扩展**：可以根据读、写负载的不同，独立地扩展命令端和查询端的资源。\n  - **性能优化**：可以为读和写选择最适合的存储技术和数据模型。\n  - **关注点分离**：简化了模型的设计，命令模型只关心业务，查询模型只关心展示。\n- **缺点**：\n  - **系统复杂性增加**：需要管理两个模型和它们之间的数据同步机制。\n  - **最终一致性**：数据同步的延迟可能不适用于所有业务场景。\n  - **代码量增加**：需要编写更多的代码来维护两个模型。\n\n## 常用工具与框架\n\n- **Axon Framework**: 一个专门用于实现CQRS、事件溯源和DDD的Java框架。\n- **消息队列 (RabbitMQ, Kafka)**: 常用于在命令端和查询端之间传递事件以同步数据。\n\n## 注意事项\n\n- CQRS是一种架构模式，而不是一个可以即插即用的技术。它会显著增加系统复杂性，不应滥用。只在确实存在读写矛盾的复杂场景下才考虑使用。\n- 它经常与**事件溯源 (Event Sourcing)** 模式一同使用，但两者是独立的，可以分开应用。"
    },
    {
      "name": "事件溯源",
      "summary": "不直接存储对象的当前状态，而是将导致对象状态改变的所有事件按顺序持久化。通过重放这些事件，可以随时重建对象的任何历史状态。",
      "notes": "# 事件溯源\n\n## 解决的问题\n\n传统的CRUD数据模型只保存实体的最新状态，丢失了状态变迁的历史过程。\n\n- **审计困难**：很难回答“这个用户的余额是如何变成现在这个样子的？”这类问题。\n- **历史状态不可追溯**：无法轻松地将系统恢复到任意过去的时间点。\n- **业务洞察缺失**：状态变更的意图和上下文信息（“为什么”变）丢失了，只剩下结果（“是什么”）。\n\n## 核心思想与实现方式\n\n事件溯源的核心思想是，**系统的唯一事实来源（Single Source of Truth）是事件日志**。所有的数据修改操作都表现为一个不可变的“事件”（Event）并被存储下来。\n\n- **事件 (Event)**：表示过去发生过的事情，例如 `OrderPlaced`、`ItemAddedToCart`、`AddressUpdated`。事件是不可变的。\n- **事件存储 (Event Store)**：一个只支持追加操作的数据库，用于按顺序持久化所有事件。\n- **聚合 (Aggregate)**：业务实体。它的当前状态是通过从头开始“重放”（Replay）其相关的历史事件计算得出的，而不是从数据库直接读取的。\n\n例如，一个银行账户的当前余额不是数据库中的一个字段，而是所有`DepositEvent`和`WithdrawalEvent`累加计算的结果。\n\n## 优缺点\n\n- **优点**：\n  - **完整的审计日志**：所有变更都有记录，提供了100%可靠的审计追踪。\n  - **可追溯的历史状态**：可以重建系统在任何时间点的状态，非常适合调试和业务分析。\n  - **灵活的查询模型**：可以通过消费事件流，构建出任意多个不同的、为查询优化的“投影”（Projections），这是实现CQRS的天然方式。\n- **缺点**：\n  - **高复杂性**：开发模式与传统CRUD完全不同，对团队要求更高。\n  - **查询复杂**：直接查询某个实体的当前状态需要重放事件，可能很慢。因此几乎总是需要与CQRS结合使用，维护一个专门的读模型。\n  - **事件模型演进**：如果事件的结构发生变化（如增加字段），需要处理版本兼容性问题。\n\n## 常用工具与框架\n\n- **Axon Framework**: 提供了对事件溯源的完整支持。\n- **EventStoreDB**: 一个专门为事件溯源设计的数据库。\n- **Apache Kafka / Pulsar**: 可以用作高吞吐量的事件存储日志。\n\n## 注意事项\n\n- 事件溯源是一种强大的模式，但也非常复杂。它适用于业务逻辑复杂、对审计和历史追溯有强需求的领域，如金融、电商订单系统等。\n- 实施事件溯源几乎必然要引入CQRS模式来解决查询性能问题。"
    }
  ]